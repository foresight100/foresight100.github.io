<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>团队年鉴-我的的2019</title>
    <link href="/2019/12/31/%E5%9B%A2%E9%98%9F%E5%B9%B4%E9%89%B4-%E6%88%91%E7%9A%84%E7%9A%842019/"/>
    <url>/2019/12/31/%E5%9B%A2%E9%98%9F%E5%B9%B4%E9%89%B4-%E6%88%91%E7%9A%84%E7%9A%842019/</url>
    
    <content type="html"><![CDATA[<ul><li>想来，作为一名新队员，团队年鉴对我而言自是意义非凡。2019年对我个人而言算是一个人生中的转折点，标志着以往18年未成年的结束，也是此后数十年的开始，是我踏出故乡的第一步。</li><li>光阴似箭，日月如梭，不知不觉一个学期就过去了，仿佛昨天才踏入华中大、来到Dian团队，在团队的三个月，我深刻体会了知识海洋的浩瀚无边，也对人的无限潜能有深刻的感悟。</li><li>“人生没有白走的路，每一步都算数。”是在今年的6月23日，当我拿到高考成绩单时，我便明白，我与华中大的缘分就此开始，我也在缓缓向Dian团队靠齐。</li><li>刚从高中升入大学的我曾把高三当作人生最苦的时期，确实，高中确实辛苦，早出晚归，做不完的作业，刷不完的习题，终日与疲劳和杂念做斗争，单调乏味和无聊痛苦交织着，怎能不苦呢？现在我才明白，原来大学绝非轻松之地，对比高中犹有过之，若高中是在永无止境的走路，那么大学便需要拼命地奔跑，但我是幸福的奔跑着的。</li><li>我一直信奉一个道理，人的所有的成就都是自身素质的体现，成绩、成就绝非智商所决定，而仅仅是个人优秀品质的必然结果。能在团队之中，我深感我的幸运。这里不是冷冰冰的技术，而是充满着人情味，这里的每月一善等暖心活动更让我见识到了一个团体的优秀素质。我学到的不仅是技术，更是坚持、善良，是对目标的坚定和永不放弃的决心。</li><li>初入大学，我学习了python，啃完了《python从入门到实践》、《以计算机学家一样思考python》，一行行简单的代码通过组合、嵌套竟能实现如此繁复的功能，对代码的热爱便由此激发，不曾想，这一段简单的经历也帮助我挺过了熬测大关。不得不又应证了开头的那段话，人生怎会有白走的路呢？</li><li>加入团队后，我选择了自己尚未接触过的语言—Java。人的潜能是无限的，千万不能停留在舒适区，那我何不选择自己毫无经验的Android作为自己的学习目标呢？怀着激动的心情，我加入了启亦电子组。</li><li>一个人走的快，但一群人才能走得远。初入项目组，我就感觉在这有大量的知识待我学习。</li><li>新人任务帮助我迅速熟悉Android。做任务的同时，配合着《第一行代码》，虽毫无Java基础，但是确实对项目结构有了初步掌握，我领到的第一份任务是制作一个简单的记事本程序。“麻雀虽小，五脏俱全”；app虽小，内容却多。从简单的选择模版，运用RecyclerView，再到构建闹铃，理解service和broadcast，同时还有数据库的增删查改，每一点知识的学会都是艰难的一步，需要付出时间和专注。</li><li>组会分享干货多多。不得不说，每周的组会真是收获颇多，编译原理、数据库运用、数据结构讲解等等，课内课外的知识有机结合，对于我而言不仅是眼界的开拓，更是对日后的学习打下的坚实的基础，帮助了我的成长，也提高了学习效率。</li><li>在队委会中，我在所在的公关组承担一部分拍照和协助接待工作，在与来宾打交道的过程中，我的沟通能力也得到了提升，让我能在未来承担更多的工作，更好地服务于团队。<br>“悟以往之不谏，知来者之可追。”总结是为了更好的提升，新一年的我已经准备好了迎接新的挑战，再接再厉，为团队的发展贡献自己的力量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>2019</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2019</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学生通讯录管理系统（一次c语言的初步探索运用）</title>
    <link href="/2019/12/22/%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%E6%AC%A1c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%E8%BF%90%E7%94%A8%EF%BC%89/"/>
    <url>/2019/12/22/%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%E6%AC%A1c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%E8%BF%90%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>纪念人生第一次手撸2000行代码 (o^^o)♪<br><a id="more"></a><br><img src="https://i.loli.net/2019/12/22/AYRUeJpuT3DLiZP.jpg" srcset="/img/loading.gif" alt></p><h1 id="学生通讯录管理系统"><a href="#学生通讯录管理系统" class="headerlink" title="学生通讯录管理系统"></a>学生通讯录管理系统</h1><ul><li><strong>c语言课程设计</strong>  <h2 id="HUST-EIC"><a href="#HUST-EIC" class="headerlink" title="HUST EIC"></a>HUST EIC</h2></li></ul><h2 id="功能概述："><a href="#功能概述：" class="headerlink" title="功能概述："></a>功能概述：</h2><p>这是基于c语言的学生通讯录管理系统，包括以下功能：</p><ul><li><strong>导入csv等二进制格式文件</strong><ul><li>检测是否重复导入：若重复导入，提醒用户是否覆盖，或者回到主界面进行添加功能</li><li>检测文件是否存在：若存在则导入，若不存在会提示“NOT FOUND”重新导入</li></ul></li><li><strong>浏览所有学生信息</strong><ul><li>一键打印所有同学的所有信息</li></ul></li><li><strong>统计与查找所有学生信息</strong><ul><li>支持按各类特征查找，如：只查找名字或只查找学院，所有查找都支持模糊查找，如只输入姓氏，或只输入学院名称的几个字</li><li>支持关键字查找：输入关键字查找所有特征（即，把名字，学院，email等与关键字一一对比）</li><li>所有查找结果都返回查找的结果的个数</li><li>所有查找都支持模糊查找</li></ul></li><li><strong>排序</strong><ul><li>排序采用设标签法</li><li>设标签后，交换采用数据域的交换，而非结点的交换，有改进空间</li></ul></li><li><strong>删除学生信息</strong><ul><li>删除学生信息就是将该结点的上一级指针指向下一级，再free该结点</li><li>有避免误删的功能，即多次确定，且打印信息</li></ul></li><li><strong>添加新的学生信息</strong><ul><li>设计了两种添加学生信息的方式：<ul><li>用户手动添加</li><li>通过读取文件添加</li></ul></li><li>两种添加方式都直接添加在末尾</li></ul></li><li><strong>修改学生信息</strong><ul><li>根据学号的唯一性，通过学号找到学生本人然后进行修改。</li><li>同样具有容错性，例如：若查找不到学生，则打印 NOTFOUND！！</li></ul></li><li><strong>导出表格</strong><ul><li>输入导出表格的路径，若存在同名同路径文件，则覆盖，若不存在，则创建   </li></ul></li><li><strong>通知</strong><ul><li>base64加密和soket部分代码为网上demo，有些库函数不知osx和windows能否兼容<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><pre><code class="lang-mermaid">graph LRA[主界面] --&gt; B[导入文件]A[主界面] --&gt; C[排序]A[主界面] --&gt; D[浏览所有]A[主界面] --&gt; E[统计和查找]A[主界面] --&gt; F[添加新的学生信息]A[主界面] --&gt; G[修改学生信息]A[主界面] --&gt; H[删除学生信息]A[主界面] --&gt; I[导出]A[主界面] --&gt; J[通知学生]A[主界面] --&gt; K(退出程序)B--&gt;输入文件路径C--&gt;按姓名字典顺序排序C--&gt;按学号排序D--&gt;列表浏览所有学生信息E--&gt;5(统计与查找)5--&gt;按学号查找5--&gt;按名字查找5--&gt;按学院查找5--&gt;按地址查找5--&gt;按电话查找5--&gt;按邮箱查找F--&gt;手动添加F--&gt;文件添加G--&gt;查找--&gt;选择修改特征--&gt;键入修改后值--&gt;修改成功H--&gt;查找删除学生信息--&gt;1{确定删除}--&gt;删除I--&gt;选择输出路径--&gt;导出成功J--&gt;输入学生邮箱--&gt;send</code></pre><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2></li></ul></li><li><strong>结构采用一个功能一个模块（子函数），实现模块间的相互独立</strong></li><li><strong>存储数据的链表的表头是全局链表，可以不用传递参数便随时调取</strong></li><li><strong>进入功能后可以随时退出，回到主界面</strong></li><li><strong>所有模块都具有容错性</strong></li><li><strong>代码除「通知」模块的一部分，其他为纯手写</strong><h2 id="不足和改进空间"><a href="#不足和改进空间" class="headerlink" title="不足和改进空间"></a>不足和改进空间</h2></li><li>在统计和查找模块，可以利用定义函数来减少代码行数，但时间不足，暂来不及改变</li><li>结构还不够简洁</li><li>对学生信息的修改功能上，没有批量修改</li><li>对学生的信息统计能统计数目，暂不能有更多的统计功能</li><li>所有数据仅支持英文，中文在terminal中测试为乱码</li><li>发送通知的功能还需继续学习更多有关通信和加密的知识<h2 id="总结收获"><a href="#总结收获" class="headerlink" title="总结收获"></a>总结收获</h2></li><li>学会了链表的增删查改</li><li>学会了用c语言读写文件</li><li>对数组、指针、结构体的运用能力更近了一层</li><li>debug能力更强</li><li>初步接触套接字</li></ul><pre><code>//</code></pre><p>  //  main.cpp<br>  //  addresslist<br>  //<br>  //  Created by 王秋辰 on 2019/12/17.<br>  //  Copyright © 2019 王秋辰. All rights reserved.</p><p>  //电信1901班   王秋辰</p><p>  /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  caution!!!!!!!<br>  atoi转换char为int<br>  表格的形式必须为类似一下例子的可读文件，csv或者txt皆可<br>  列分隔用“，”。行分隔用’\n’</p><p>  name,num,sex,college,major,add,tel,QQ,email<br>  mike,U201912345,1,EIC,eletricial information,yunyuan 23 107,13972108706,1194798160,1194798160@qq.com<br>  john,U201912346,0,CS,computer science,yunyuan 22 106,13972108707,1194798161,1194798160@qq.com<br>  eric,U201912347,1,EIC,eletricial information,yunyuan 23 106,13972108708,1194798162,1194798160@qq.com</p><p>  通知功能需要配置邮箱的   POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 才能使用 &lt;&lt;—(不太懂)</p><p>  <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><p>  //email模块所需</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <sys types.h></sys></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <sys socket.h></sys></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <netinet in.h></netinet></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <errno.h></errno.h></h1><h1 id="include-4"><a href="#include-4" class="headerlink" title="include "></a>include <unistd.h></unistd.h></h1><h1 id="include-5"><a href="#include-5" class="headerlink" title="include "></a>include <sys time.h></sys></h1><h1 id="include-6"><a href="#include-6" class="headerlink" title="include "></a>include <cstring></cstring></h1><h1 id="include-7"><a href="#include-7" class="headerlink" title="include "></a>include <arpa inet.h></arpa></h1><p>  //</p><h1 id="include-8"><a href="#include-8" class="headerlink" title="include "></a>include <iostream></iostream></h1><h1 id="include-9"><a href="#include-9" class="headerlink" title="include "></a>include <stdio.h></stdio.h></h1><h1 id="include-10"><a href="#include-10" class="headerlink" title="include "></a>include <stdlib.h></stdlib.h></h1><h1 id="include-11"><a href="#include-11" class="headerlink" title="include "></a>include <string.h></string.h></h1><h1 id="define-NAMESIZE-99"><a href="#define-NAMESIZE-99" class="headerlink" title="define NAMESIZE 99"></a>define NAMESIZE 99</h1><h1 id="define-MAJORSIZE-99"><a href="#define-MAJORSIZE-99" class="headerlink" title="define MAJORSIZE 99"></a>define MAJORSIZE 99</h1><h1 id="define-ADDSIZE-99"><a href="#define-ADDSIZE-99" class="headerlink" title="define ADDSIZE 99"></a>define ADDSIZE 99</h1><h1 id="define-EMAILSIZE-99"><a href="#define-EMAILSIZE-99" class="headerlink" title="define EMAILSIZE 99"></a>define EMAILSIZE 99</h1><h1 id="define-COLLEGESIZE-99"><a href="#define-COLLEGESIZE-99" class="headerlink" title="define COLLEGESIZE 99"></a>define COLLEGESIZE 99</h1><h1 id="define-NUMSIZE-99"><a href="#define-NUMSIZE-99" class="headerlink" title="define NUMSIZE 99"></a>define NUMSIZE 99</h1><h1 id="define-TELSIZE-99"><a href="#define-TELSIZE-99" class="headerlink" title="define TELSIZE 99"></a>define TELSIZE 99</h1><h1 id="define-QQSIZE-99"><a href="#define-QQSIZE-99" class="headerlink" title="define QQSIZE 99"></a>define QQSIZE 99</h1><h1 id="define-SIZE-99-存储的最大容量"><a href="#define-SIZE-99-存储的最大容量" class="headerlink" title="define SIZE 99//存储的最大容量"></a>define SIZE 99//存储的最大容量</h1><h1 id="define-FILEPATHSIZE-99"><a href="#define-FILEPATHSIZE-99" class="headerlink" title="define FILEPATHSIZE 99"></a>define FILEPATHSIZE 99</h1><h1 id="define-CHANGESIZE-40"><a href="#define-CHANGESIZE-40" class="headerlink" title="define CHANGESIZE 40"></a>define CHANGESIZE 40</h1><p>  using namespace std;</p><p>  typedef struct student{<br>      char name[NAMESIZE];//姓名<br>      char num[NUMSIZE];//学号<br>      int sex;//man:1  woman:0<br>      char college[COLLEGESIZE];//学院<br>      char major[MAJORSIZE];//专业<br>      char add[ADDSIZE];//地址<br>      char tel[TELSIZE];//电话<br>      char QQ[QQSIZE];//qq<br>      char email[EMAILSIZE];//电子邮箱<br>  } datatype;</p><p>  typedef struct linknode{<br>      datatype studentdata;<br>      linknode <em>next;<br>  } Node,</em>linklist;//定义节点</p><p>  linknode <em>head=(Node</em>)malloc(sizeof(Node));//表头</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>    打印所有学生信息模块声明           <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void printlink();//打印所有学生信息的界面<br>  void output();//展示所有信息</p><p>  int menu(void);//主菜单<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>          导入模块声明             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void create(char filepath[FILEPATHSIZE]);//=根据文件路径导入；创建链表<br>  void input();//导入信息界面<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找模块声明             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void Find();//查找界面<br>  int checksubstr(char <em>str,char </em>sub_str);//检查字符串中是否包含子字符串<br>  void printsingle(Node <em>p);//打印单个节点学生数据<br>  int Findnum();//查找学号界面；输入学号<br>  void searchnum(char </em>search);//按学号查找<br>  int Findname();//按姓名查找界面;输入关键字<br>  void searchname(char <em>search);//按姓名查找<br>  int Findtel();//按电话查找界面;输入关键字<br>  void searchtel(char </em>search);//按电话查找<br>  int FindQQ();//按QQ查找界面;输入关键字<br>  void searchQQ(char <em>search);//按QQ查找<br>  int Findall();//关键字查找<br>  void searchall(char </em>search);<br>  int Findsex();//性别查找<br>  void searchsex(int search);<br>  int Findmajor();//专业查找<br>  void searchmajor(char <em>search);<br>  int Findaddress();//地址查找<br>  void searchaddress(char </em>search);<br>  int Findcollege();//学院查找<br>  void searchcollege(char <em>search);<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><em>**</em></strong></strong></em>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           修改数据模块声明             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void changedata();//界面<br>  linklist searchnumchange(char <em>search);//找到待修改的值，并返回节点指针<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><em>**</em></strong></strong></em>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           删除数据模块声明          <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void deletedata();//界面<br>  linklist findthefront();//找到待c删除节点的前一个节点，返回指针</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           添加数据模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void adddata();//界面<br>  void writebyhand();//手动写入<br>  void writebyfile();//文件写入</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           导出数据模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void exportdata();//界面和导出<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           排序模块声明             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void sortdata();//界面<br>  void sortbynum();//按学号排序<br>  void exchange(linknode <em>p,linknode </em>q);//交换两个指针内的data<br>  void sortbyname();//按name排序</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           发送邮件             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void send();<br>  struct data6<br>  {<br>      unsigned int d4:6;<br>      unsigned int d3:6;<br>      unsigned int d2:6;<br>      unsigned int d1:6;<br>  };<br>  // 协议中加密部分使用的是base64方法<br>  char con628(char c6);<br>  void base64(char <em>dbuf,char </em>buf128,int len);<br>  void sendemail(char <em>email,char </em>body);<br>  int open_socket(struct sockaddr <em>addr);<br>  void sendto(char </em>email);<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           主函数。                <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int main() {<br>      system(“clear”);//osx环境<br>      menu();<br>      return 0;<br>  }<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           主菜单。                <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int menu(void){<br>      cout&lt;&lt;”|———————————————“&lt;&lt;endl;<br>      cout&lt;&lt;”|-&gt;这里是学生通讯录管理系统&lt;-|”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[1]-导入”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[2]-按条件排序”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[3]-浏览所有学生信息”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[4]-统计与查找”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[5]-添加新的学生信息”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[6]-修改学生信息”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[7]-删除学生信息”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[8]-导出”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[9]-通知学生”&lt;&lt;endl;<br>      cout&lt;&lt;”|——[0]-退出程序”&lt;&lt;endl;<br>      cout&lt;&lt;”|———————————————“&lt;&lt;endl;<br>      cout&lt;&lt;”请输入要进行的操作-&gt;”&lt;&lt;endl;</p><pre><code>  int n=-1;  scanf(&quot;%d&quot;,&amp;n);  if (n&lt;=9&amp;&amp;n&gt;=1) {      switch (n) {          case 1:              system(&quot;clear&quot;);              input();              break;          case 2:              system(&quot;clear&quot;);              sortdata();              break;          case 3:              system(&quot;clear&quot;);              output();              break;          case 4:              system(&quot;clear&quot;);              Find();              break;          case 5:              system(&quot;clear&quot;);              adddata();              break;          case 6:              system(&quot;clear&quot;);              changedata();              break;          case 7:              system(&quot;clear&quot;);              deletedata();              break;          case 8:              system(&quot;clear&quot;);              exportdata();              break;          case 9:              system(&quot;clear&quot;);              send();              break;          case 0:              exit(1);          default:              break;      }}  else{      fflush(stdin);      system(&quot;clear&quot;);//osx环境      printf(&quot;请键入正确的操作！！！\n&quot;);      menu();  }  return 0;</code></pre><p>  }<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           通知模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           排序模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  void sortdata(){<br>      cout&lt;&lt;”|————[1]-按姓名排序”&lt;<endl; cout<<"|--------[2]-按学号排序"<<endl; cout<<"|--------[0]-返回主菜单"<<endl; cout<<"|--------请输入你的选项："<<endl; int n="-1;" scanf("%d",&n); fflush(stdin); switch (n) { case 1: sortbyname(); system("clear"); cout<<"-------------------------------------------"<<endl; cout<<">>>>>>>>>>                     <<<<<<<<<<<<"<<endl; cout<<">>>>>>>>>>      姓氏排序成功！    <<<<<<<<<<<<"<<endl; cout<<">>>>>>>>>>                     <<<<<<<<<<<<"<<endl; cout<<"-------------------------------------------"<<endl; menu(); break; case 2: sortbynum(); system("clear"); cout<<">>>>>>>>>>                     <<<<<<<<<<<<"<<endl; cout<<">>>>>>>>>>      学号排序成功！    <<<<<<<<<<<<"<<endl; cout<<">>>>>>>>>>                     <<<<<<<<<<<<"<<endl; cout<<"-------------------------------------------"<<endl; menu(); break; case 0: system("clear"); printf(">>>>请输入正确的选项!!!!!<<<<"); sortdata(); exit(1); break; default: } ************************************************************** ************* *************** 按学号排序 void sortbynum(){ linknode *p,*q; p="head;" while (p) { q="p-">next;<br>          linknode *themin=p;<br>          while (q) {<br>              if (strcmp(p-&gt;studentdata.num, q-&gt;studentdata.num)&gt;0) {<br>                  themin=q;<br>              }<br>              q=q-&gt;next;<br>          }<br>          exchange(p, themin);<br>          p=p-&gt;next;<br>      }<br>  }</");></"<<endl;></"<<endl;></"<<endl;></"<<endl;></"<<endl;></"<<endl;></endl;></p><p>  void exchange(linknode <em>p,linknode </em>q)<br>  {<br>      linknode <em>temp=(linknode</em>)malloc(sizeof(Node));<br>      temp-&gt;studentdata = p-&gt;studentdata;<br>      p-&gt;studentdata = q-&gt;studentdata;<br>      q-&gt;studentdata = temp -&gt; studentdata;<br>      free(temp);<br>  }<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           按姓名排序             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void sortbyname(){<br>      linknode <em>p,</em>q;<br>      p=head;<br>      while (p) {<br>          q=p-&gt;next;<br>          linknode *themin=p;<br>          while (q) {<br>              if (strcmp(p-&gt;studentdata.name, q-&gt;studentdata.name)&gt;0) {<br>                  themin=q;<br>              }<br>              q=q-&gt;next;<br>          }<br>          exchange(p, themin);<br>          p=p-&gt;next;<br>      }<br>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           导出数据模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void exportdata(){<br>      fflush(stdin);<br>      cout&lt;&lt;”|———————————————-“&lt;<endl; cout<<"返回上一级则按回车键"<<endl; cout<<"请输入导出文件路径(若文件存在，则会被覆盖)："<<endl; char filepath[filepathsize]; gets(filepath); if (filepath[0]="='\0')" { system("clear"); menu(); } file *fp="fopen(filepath," "w"); node *read="head-">next;<br>      fputs(“name,num,sex,college,major,add,tel,QQ,email\n”, fp);<br>      while (read) {<br>          char tempsex[2];<br>          if (read-&gt;studentdata.sex==1) {<br>              strcpy(tempsex, “1”);<br>          }<br>          if (read-&gt;studentdata.sex==0) {<br>              strcpy(tempsex, “0”);<br>          }<br>          fputs(read-&gt;studentdata.name, fp);<br>          fputs(“,”, fp);<br>          fputs(read-&gt;studentdata.num, fp);<br>          fputs(“,”, fp);<br>          fputs(tempsex, fp);<br>          fputs(“,”, fp);<br>          fputs(read-&gt;studentdata.college, fp);<br>          fputs(“,”, fp);<br>          fputs(read-&gt;studentdata.major, fp);<br>          fputs(“,”, fp);<br>          fputs(read-&gt;studentdata.add, fp);<br>          fputs(“,”, fp);<br>          fputs(read-&gt;studentdata.tel, fp);<br>          fputs(“,”, fp);<br>          fputs(read-&gt;studentdata.QQ, fp);<br>          fputs(“,”, fp);<br>          fputs(read-&gt;studentdata.email, fp);<br>          read=read-&gt;next;<br>      }<br>      fclose(fp);<br>      system(“clear”);<br>      cout&lt;&lt;”导出文件成功!”&lt;&lt;endl;<br>      cout&lt;&lt;”文件在”&lt;&lt;filepath&lt;&lt;”中”&lt;&lt;endl;<br>      cout&lt;&lt;”按任意键回到主菜单”&lt;&lt;endl;<br>      getchar();<br>      system(“clear”);<br>      fflush(stdin);<br>      menu();<br>      exit(1);<br>  }</endl;></p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           添加数据模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  void adddata()<br>  {<br>      fflush(stdin);<br>      cout&lt;&lt;”|————-[1]-从当前界面手动写入”&lt;&lt;endl;<br>      cout&lt;&lt;”|————-[2]-从文件导入，从数据最后一行添加”&lt;&lt;endl;<br>      cout&lt;&lt;”|————-[3]-回到主界面”&lt;&lt;endl;<br>      cout&lt;&lt;”请输入你的选项:”&lt;&lt;endl;<br>      int n = 0;<br>      fflush(stdin);<br>      scanf(“%d”,&amp;n);<br>      fflush(stdin);<br>      switch (n) {<br>          case 1:<br>              writebyhand();<br>              break;<br>          case 2:<br>              writebyfile();<br>              break;<br>          case 3:<br>              fflush(stdin);<br>              system(“clear”);<br>              menu();<br>              exit(1);<br>          default:<br>              fflush(stdin);<br>              system(“clear”);<br>              adddata();<br>              break;<br>      }<br>      exit(1);<br>  }</p><p>  void writebyhand(){<br>      fflush(stdin);<br>      char <em>temname=(char</em>)malloc(NAMESIZE);<br>      char <em>temnum=(char</em>)malloc(NUMSIZE);<br>      int temsex=2;<br>      char <em>temcollege=(char</em>)malloc(COLLEGESIZE);<br>      char <em>temmajor=(char</em>)malloc(MAJORSIZE);<br>      char <em>temadd=(char</em>)malloc(ADDSIZE);<br>      char <em>temtel=(char</em>)malloc(TELSIZE);<br>      char <em>temQQ=(char</em>)malloc(QQSIZE);<br>      char <em>tememail=(char</em>)malloc(EMAILSIZE);<br>      cout&lt;&lt;”请输入姓名”&lt;<endl; gets(temname); cout<<"请输入学号"<<endl; gets(temnum); while (!(temsex="=1||temsex==0))" { cout<<"请输入性别(男生为1，女生为0)"<<endl; scanf("%d",&temsex); if temsex="2;" cout<<"请输入正确的数据!!!"<<endl; } fflush(stdin); cout<<"请输入学院"<<endl; gets(temcollege); cout<<"请输入专业"<<endl; gets(temmajor); cout<<"请输入地址"<<endl; gets(temadd); cout<<"请输入电话"<<endl; gets(temtel); cout<<"请输入qq"<<endl; gets(temqq); cout<<"请输入email"<<endl; fgets(tememail, emailsize, stdin); linknode *theend="head;" (theend->next) {<br>          theend=theend-&gt;next;<br>      }<br>      linknode *tem;</endl;></p><pre><code>  tem=(Node*)malloc(sizeof(Node));  strcpy(tem-&gt;studentdata.name,temname);  strcpy(tem-&gt;studentdata.num,temnum);  tem-&gt;studentdata.sex=temsex;  strcpy(tem-&gt;studentdata.college,temcollege);  strcpy(tem-&gt;studentdata.major,temmajor);  strcpy(tem-&gt;studentdata.add,temadd);  strcpy(tem-&gt;studentdata.tel,temtel);  strcpy(tem-&gt;studentdata.QQ,temQQ);  strcpy(tem-&gt;studentdata.email,tememail);  tem-&gt;next=NULL;  theend-&gt;next=tem;  free(temadd);  free(tememail);  free(temtel);  free(temQQ);  free(temmajor);  free(temcollege);  free(temnum);  free(temname);  fflush(stdin);  system(&quot;clear&quot;);  cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;  cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;  cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      手动导入成功！       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;  cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;  cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;  menu();  exit(1);</code></pre><p>  }</p><p>  void writebyfile()<br>  {<br>      cout&lt;&lt;”|———————————————-“&lt;<endl; cout<<"返回上一级则按回车键"<<endl; cout<<"请输入导入文件路径："<<endl; char filepath[filepathsize]; gets(filepath); if (filepath[0]="='\0')" { system("clear"); menu(); } file *fp; while ((fp="fopen(filepath," "r"))="=NULL)" printf("not found！！请再次输入:\n"); break; linknode *theend="head;" (theend->next) {<br>          theend=theend-&gt;next;<br>      }<br>      fp=fopen(filepath, “r”);<br>      linknode <em>p,</em>q;<br>      p=q=theend;<br>      char buffer[1024];<br>      char <em>line,</em>record;//c保存行数据,单个列元素<br>      line=fgets(buffer, sizeof(buffer), fp);//丢掉第一行<br>      while ((line=fgets(buffer, sizeof(buffer), fp))!=NULL) {<br>          q=(Node*)malloc(sizeof(Node));</endl;></p><pre><code>      record = strtok(line, &quot;,&quot;);      strcpy(q-&gt;studentdata.name,record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.num,record);      record = strtok(NULL, &quot;,&quot;);      q-&gt;studentdata.sex=atoi(record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.college,record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.major, record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.add, record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.tel,record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.QQ,record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.email, record);      p-&gt;next=q;      p=q;  }  p-&gt;studentdata.email[strlen(q-&gt;studentdata.email)+1]=&#39;\0&#39;;  p-&gt;studentdata.email[strlen(q-&gt;studentdata.email)]=&#39;\n&#39;;  p-&gt;next=NULL;  fclose(fp);  fflush(stdin);  system(&quot;clear&quot;);  cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;  cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;  cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      文件导入成功！    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;  cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;  cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;  menu();  exit(1);</code></pre><p>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           删除数据模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void deletedata(){<br>      fflush(stdin);<br>      cout&lt;&lt;”请输入要删除的学生学号「完整学号」：”&lt;<endl; cout<<"输入q回到主界面"<<endl; char *studentnum="(char*)malloc(NUMSIZE);" gets(studentnum); if (strcmp(studentnum, "q")="=0)" { system("clear"); menu(); exit(1); } linklist target="searchnumchange(studentnum);" if(target){ printsingle(target->next);<br>          printf(“确定删除吗？（y/n）”);<br>          fflush(stdin);<br>          char <em>check=(char</em>)malloc(sizeof(3));<br>          gets(check);<br>          if (strcmp(check, “y”)==0||strcmp(check, “Y”)==0) {<br>              linklist p=target-&gt;next;<br>              target-&gt;next=p-&gt;next;<br>              free(p);<br>              free(target);<br>              free(check);<br>              system(“clear”);<br>              cout&lt;&lt;”删除成功”&lt;&lt;endl;<br>              deletedata();<br>          }<br>          else{<br>              free(target);<br>              free(check);<br>              system(“clear”);<br>              fflush(stdin);<br>              deletedata();<br>          }<br>      }<br>      else<br>      {<br>          fflush(stdin);<br>          free(target);<br>          free(studentnum);<br>          system(“clear”);<br>          printf(“NOT FOUND”);<br>          deletedata();<br>          exit(1);<br>      }<br>  }</endl;></p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           修改数据模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void changedata(){<br>      fflush(stdin);<br>      cout&lt;&lt;”请输入要修改的学生学号「完整学号」：”&lt;<endl; cout<<"输入q回到主界面"<<endl; char *studentnum="(char*)malloc(NUMSIZE);" gets(studentnum); if (strcmp(studentnum, "q")="=0)" { system("clear"); menu(); exit(1); } linklist check="searchnumchange(studentnum);" if(check){ while (check) printsingle(check); cout<<"[1]修改姓名"<<endl; cout<<"[2]修改学号"<<endl; cout<<"[3]修改性别(男生为1，女生为2）"<<endl; cout<<"[4]修改学院"<<endl; cout<<"[5]修改专业"<<endl; cout<<"[6]修改地址"<<endl; cout<<"[7]修改电话"<<endl; cout<<"[8]修改qq"<<endl; cout<<"[9]修改电子邮箱"<<endl; cout<<"[其他任意]返回主页面"<<endl; cout<<"请输入你的选项:"<<endl; int n="-1;" scanf("%d",&n); (!(n<="9&&n">=1)) {<br>              changedata();<br>          }<br>          fflush(stdin);<br>          cout&lt;&lt;”修改为：”&lt;<endl; char *change="(char*)malloc(sizeof(CHANGESIZE));" gets(change); switch (n) { case 1: strcpy(check->studentdata.name,change);<br>                  break;<br>              case 2:<br>                  strcpy(check-&gt;studentdata.num, change);<br>                  break;<br>              case 3:<br>                  if(strcmp(change,”1”)==0)<br>                      check-&gt;studentdata.sex=1;<br>                  else if(strcmp(change,”2”)==0)<br>                      check-&gt;studentdata.sex=0;<br>                  break;<br>              case 4:<br>                  strcpy(check-&gt;studentdata.college, change);<br>                  break;<br>              case 5:<br>                  strcpy(check-&gt;studentdata.major, change);<br>                  break;<br>              case 6:<br>                  strcpy(check-&gt;studentdata.add, change);<br>                  break;<br>              case 7:<br>                  strcpy(check-&gt;studentdata.tel, change);<br>                  break;<br>              case 8:<br>                  strcpy(check-&gt;studentdata.QQ, change);<br>                  break;<br>              case 9:<br>                  strcpy(check-&gt;studentdata.email, change);<br>                  break;<br>              default:<br>                  break;<br>          }</endl;></endl;></p><pre><code>      fflush(stdin);      cout&lt;&lt;&quot;修改成功!!!!&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;需要继续修改吗（y/n）?&quot;&lt;&lt;endl;      char *goon=(char*)malloc(sizeof(4));          gets(goon);          if (strcmp(goon,&quot;y&quot;)==0||strcmp(goon, &quot;Y&quot;)==0) {              free(goon);              continue;          }          else{              free(change);              free(studentnum);              free(goon);              system(&quot;clear&quot;);              menu();              exit(1);          }  }  }  else{      free(studentnum);      system(&quot;clear&quot;);      printf(&quot;NOT FOUND&quot;);      changedata();      exit(1);  }</code></pre><p>  }</p><p>  linklist searchnumchange(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;studentdata.num, search)==1) {<br>              return p;<br>          }<br>          p=p-&gt;next;<br>      }<br>      return NULL;<br>  }<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找数据模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  void Find(void){<br>      cout&lt;&lt;”|———————————————-“&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[1]-按【姓名】统计与查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[2]-按【学号】统计与查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[3]-按【电话】查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[4]-按【QQ】查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[5]-按【学院】统计与查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[6]-按【专业】统计与查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[7]-按【地址】统计与查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[8]-按【性别】统计与查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[9]-关键字查找”&lt;&lt;endl;<br>      cout&lt;&lt;”｜——[0]-返回主界面”&lt;&lt;endl;<br>      cout&lt;&lt;”<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>“&lt;&lt;endl;<br>      cout&lt;&lt;”<strong><strong>*</strong></strong>                   caution!                  <strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>“&lt;&lt;endl;<br>      cout&lt;&lt;”<strong><strong>*</strong></strong>    按特征查找支持模糊查找，例如：姓名可输入姓氏查找   <strong><strong><strong>*</strong></strong></strong>“&lt;&lt;endl;<br>      cout&lt;&lt;”<strong><strong>*</strong></strong>           关键字查找会对所有特征进行查找           <strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>“&lt;&lt;endl;<br>      cout&lt;&lt;”<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>“&lt;&lt;endl;<br>      cout&lt;&lt;”请输入选项:”&lt;&lt;endl;<br>      int n = 0;<br>      scanf(“%d”,&amp;n);<br>      fflush(stdin);<br>      switch (n) {<br>          case 1:<br>              system(“clear”);<br>              Findname();<br>              break;<br>          case 2:<br>              system(“clear”);<br>              Findnum();<br>              break;<br>          case 3:<br>              system(“clear”);<br>              Findtel();<br>              break;<br>          case 4:<br>              system(“clear”);<br>              FindQQ();<br>              break;<br>          case 5:<br>              system(“clear”);<br>              Findcollege();<br>              break;<br>          case 6:<br>              system(“clear”);<br>              Findmajor();<br>              break;<br>          case 7:<br>              system(“clear”);<br>              Findaddress();<br>              break;<br>          case 8:<br>              system(“clear”);<br>              Findsex();<br>              break;<br>          case 9:<br>              system(“clear”);<br>              Findall();<br>              break;<br>          default:<br>              system(“clear”);<br>              menu();<br>              break;<br>      }<br>  }</p><p>  linklist findthefront(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;next-&gt;studentdata.num, search)==1) {<br>              return p;<br>          }<br>          p=p-&gt;next;<br>      }<br>      return NULL;<br>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           关键字查找模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int Findall(){<br>      cout&lt;&lt;”请输入关键字：\n”&lt;&lt;endl;<br>      char <em>search=(char</em>)malloc(sizeof(char)*15);<br>      gets(search);<br>      searchall(search);<br>      free(search);<br>      printf(“\n按两次任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchall(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      int n=0;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;studentdata.num, search)||<br>              checksubstr(p-&gt;studentdata.name, search)||<br>              checksubstr(p-&gt;studentdata.tel, search)||<br>              checksubstr(p-&gt;studentdata.QQ, search)||<br>              checksubstr(p-&gt;studentdata.add, search)||<br>              checksubstr(p-&gt;studentdata.college, search)||<br>              checksubstr(p-&gt;studentdata.email, search)||<br>              checksubstr(p-&gt;studentdata.major, search)) {<br>              n++;<br>              printsingle(p);<br>          }<br>          p=p-&gt;next;<br>      }<br>      printf(“\n查找完毕,共%d条结果”,n);<br>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找学院模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int Findcollege(){<br>      cout&lt;&lt;”请输入学院或学院名称关键字：\n”&lt;&lt;endl;<br>      char <em>search=(char</em>)malloc(sizeof(char)*15);<br>      gets(search);<br>      searchcollege(search);<br>      free(search);<br>      printf(“\n按两次任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchcollege(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      int n=0;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;studentdata.college, search)==1) {<br>              n++;<br>              printsingle(p);</p><pre><code>      }      p=p-&gt;next;  }  printf(&quot;\n查找完毕,共%d条结果&quot;,n);</code></pre><p>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找专业模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int Findmajor(){<br>      cout&lt;&lt;”请输入学院或学院名称关键字：\n”&lt;&lt;endl;<br>      char <em>search=(char</em>)malloc(sizeof(char)*15);<br>      gets(search);<br>      searchmajor(search);<br>      free(search);<br>      printf(“\n按两次任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchmajor(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      int n=0;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;studentdata.major, search)==1) {<br>              n++;<br>              printsingle(p);<br>          }<br>          p=p-&gt;next;<br>      }<br>      printf(“\n查找完毕,共%d条结果”,n);<br>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找地址模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int Findaddress(){<br>      cout&lt;&lt;”请输入专业或专业名称关键字：\n”&lt;&lt;endl;<br>      char <em>search=(char</em>)malloc(sizeof(char)*15);<br>      gets(search);<br>      searchcollege(search);<br>      free(search);<br>      printf(“\n按任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchaddress(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      int n=0;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;studentdata.add, search)==1) {<br>              n++;<br>              printsingle(p);</p><pre><code>      }      p=p-&gt;next;  }  printf(&quot;\n查找完毕,共%d条结果&quot;,n);</code></pre><p>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找性别模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int Findsex(){<br>      cout&lt;&lt;”请输入性别（男生键入数字1，女生键入数字0）：\n”&lt;&lt;endl;<br>      int search = -1;<br>      scanf(“%d”,&amp;search);<br>      searchsex(search);<br>      printf(“\n按两次任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchsex(int search){<br>      int n = 0;<br>      Node *p=head-&gt;next;<br>      while (p!=NULL) {<br>          if (p-&gt;studentdata.sex==search) {<br>              n++;<br>              printsingle(p);</p><pre><code>      }      p=p-&gt;next;  }  printf(&quot;\n查找完毕,共%d条结果&quot;,n);</code></pre><p>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找学号模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int Findnum(){<br>      cout&lt;&lt;”请输入学号或部分学号：\n”&lt;&lt;endl;<br>      char <em>search=(char</em>)malloc(sizeof(char)*15);<br>      gets(search);<br>      searchnum(search);<br>      free(search);<br>      printf(“\n按两次任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchnum(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      int n=0;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;studentdata.num, search)==1) {<br>              n++;<br>              printsingle(p);</p><pre><code>      }      p=p-&gt;next;  }  printf(&quot;\n查找完毕,共%d条结果&quot;,n);</code></pre><p>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找姓名模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int Findname(){<br>      cout&lt;&lt;”请输入姓名或关键字：\n”&lt;&lt;endl;<br>      char <em>search=(char</em>)malloc(sizeof(char)*15);<br>      gets(search);<br>      searchname(search);<br>      free(search);<br>      printf(“\n按两次任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchname(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      int n = 0;<br>      while (p) {<br>          if (checksubstr(p-&gt;studentdata.name, search)==1) {<br>              n++;<br>              printsingle(p);<br>          }<br>          p=p-&gt;next;<br>      }<br>      printf(“\n查找完毕,共%d条结果”,n);<br>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找电话模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int Findtel(){<br>      cout&lt;&lt;”请输入电话或部分电话号码：\n”&lt;&lt;endl;<br>      char <em>search=(char</em>)malloc(sizeof(char)*15);<br>      gets(search);<br>      searchtel(search);<br>      free(search);<br>      printf(“\n按两次任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchtel(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      int n = 0;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;studentdata.tel, search)==1) {<br>              n++;<br>              printsingle(p);<br>          }<br>          p=p-&gt;next;<br>      }<br>      printf(“\n查找完毕,共%d条结果”,n);<br>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           查找QQ模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  int FindQQ(){<br>      cout&lt;&lt;”请输入QQ号或部分QQ号：\n”&lt;&lt;endl;<br>      char <em>search=(char</em>)malloc(sizeof(char)*15);<br>      gets(search);<br>      searchQQ(search);<br>      free(search);<br>      printf(“\n按两次任意键返回查找界面”);<br>      getchar();<br>      getchar();<br>      system(“clear”);<br>      Find();<br>      return 0;<br>  }</p><p>  void searchQQ(char <em>search){<br>      Node </em>p=head-&gt;next;<br>      int n = 0;<br>      while (p!=NULL) {<br>          if (checksubstr(p-&gt;studentdata.QQ, search)==1) {<br>              n++;<br>              printsingle(p);<br>          }<br>          p=p-&gt;next;<br>      }<br>      printf(“\n查找完毕,共%d条结果”,n);<br>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>      打印单个节点内的数据            <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  void printsingle(Node <em>p){<br>      int sex=p-&gt;studentdata.sex;<br>      char sexchar[4];<br>      if (sex==0) {<br>          strcpy(sexchar, “女”);<br>      }<br>      else{<br>          strcpy(sexchar, “男”);<br>      }<br>      printf(“%-15s”,p-&gt;studentdata.name);//名字位数<br>      printf(“%-10s\t”,p-&gt;studentdata.num);//学号位数<br>      printf(“%-7s”,sexchar);<br>      printf(“%-10s”,p-&gt;studentdata.college);//学院<br>      printf(“%-32s”,p-&gt;studentdata.major);//专业<br>      printf(“%-24s”,p-&gt;studentdata.add);//address<br>      printf(“%-16s”,p-&gt;studentdata.tel);<br>      printf(“%-12s”,p-&gt;studentdata.QQ);<br>      printf(“%s”,p-&gt;studentdata.email);<br>  }<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><em>**</em></strong></strong></em>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>      检查字符串中是否包含某段字符串    <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  int checksubstr(char <em>str,char </em>sub_str)<br>  {<br>      int count = 0;<br>      for(int i=0;i<strlen(str);i++) { int j="0;" for(;j<strlen(sub_str);j++) if(*(sub_str+j)!="*(str+i+j))" break; } if(j="=strlen(sub_str))count++;" if (count>0) {<br>          return 1;<br>      }<br>      else{<br>          return 0 ;<br>      }<br>  }</strlen(str);i++)></p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           输出数据模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  void output(){<br>      system(“clear”);<br>      cout&lt;&lt;”键入\t1\t以确定输出所有的数据”&lt;&lt;endl;<br>      cout&lt;&lt;”键入\t2\t以回到主界面”&lt;&lt;endl;<br>      int n;<br>      scanf(“%d”,&amp;n);<br>      switch (n) {<br>          case 1:<br>              system(“clear”);<br>              printlink();<br>              break;<br>          case 2:<br>              system(“clear”);<br>              menu();<br>          default:<br>              system(“clear”);<br>              output();<br>              break;<br>      }<br>  }<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           打印全部数据            <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  void printlink(){<br>      Node *p=head-&gt;next;<br>      cout&lt;&lt;”name       \t”<br>      &lt;&lt;”number      \t”<br>      &lt;&lt;”sex   “<br>      &lt;&lt;”college   “<br>      &lt;&lt;”major   \t\t\t”<br>      &lt;&lt;”address     \t\t”<br>      &lt;&lt;”tel             “<br>      &lt;&lt;”QQ          “<br>      &lt;&lt;”Email       “<br>      &lt;&lt;endl;</p><pre><code>  while (p) {      int sex=p-&gt;studentdata.sex;      char sexchar[4];      if (sex==0) {          strcpy(sexchar, &quot;女&quot;);      }      else{          strcpy(sexchar, &quot;男&quot;);      }      printf(&quot;%-15s&quot;,p-&gt;studentdata.name);//名字位数      printf(&quot;%-10s\t&quot;,p-&gt;studentdata.num);//学号位数      printf(&quot;%-7s&quot;,sexchar);      printf(&quot;%-10s&quot;,p-&gt;studentdata.college);//学院      printf(&quot;%-32s&quot;,p-&gt;studentdata.major);//专业      printf(&quot;%-24s&quot;,p-&gt;studentdata.add);//address      printf(&quot;%-16s&quot;,p-&gt;studentdata.tel);      printf(&quot;%-12s&quot;,p-&gt;studentdata.QQ);      printf(&quot;%s&quot;,p-&gt;studentdata.email);      p=p-&gt;next;  }  printf(&quot;\n输出完毕\n键入回车以回到主菜单&quot;);  getchar();  getchar();  system(&quot;clear&quot;);  menu();</code></pre><p>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           从文件导入模块             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  void input(){<br>      fflush(stdin);<br>      if ((head-&gt;next-&gt;studentdata.name)!=NULL) {<br>          printf(“已导入，若要加入数据，请在主菜单选择添加\n”);<br>          printf(“键入yes覆盖以前的数据\n”);<br>          printf(“键入其他键返回主菜单\n”);<br>          char check[3]={0};<br>          gets(check);<br>          if (strcmp(check, “yes”)==0) {<br>          }<br>          else{<br>              system(“clear”);<br>              menu();<br>              exit(1);<br>          }<br>      }<br>      cout&lt;&lt;”|———————————————-“&lt;&lt;endl;<br>      cout&lt;&lt;”返回上一级则按回车键”&lt;&lt;endl;<br>      cout&lt;&lt;”请输入导入文件路径：”&lt;&lt;endl;<br>      char filepath[FILEPATHSIZE];<br>      gets(filepath);<br>      if (filepath[0]==’\0’) {<br>          system(“clear”);<br>          menu();<br>      }<br>      FILE <em>fp;<br>      while ((fp=fopen(filepath, “r”))==NULL) {<br>          printf(“NOT FOUND！！请再次输入:\n”);<br>          gets(filepath);<br>          if (filepath[0]==’\0’)<br>          {<br>              system(“clear”);<br>              menu();<br>              break;<br>          }<br>      }<br>              create(filepath);<br>              system(“clear”);<br>      cout&lt;&lt;”—————————————————————-“&lt;&lt;endl;<br>      cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>      cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      导入成功！       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>      cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>      cout&lt;&lt;”—————————————————————-“&lt;&lt;endl;<br>              menu();<br>  }<br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><em>**</em></strong></strong></em>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           导入文件并创建链表             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  void create(char filepath[FILEPATHSIZE]){<br>      FILE <em>fp;<br>      fp=fopen(filepath, “r”);<br>      linknode </em>p,<em>q;<br>      p=q=::head;<br>      char buffer[1024];<br>      char </em>line,<em>record;//c保存行数据,单个列元素<br>      line=fgets(buffer, sizeof(buffer), fp);//丢掉第一行<br>      while ((line=fgets(buffer, sizeof(buffer), fp))!=NULL) {<br>          q=(Node</em>)malloc(sizeof(Node));</p><pre><code>      record = strtok(line, &quot;,&quot;);      strcpy(q-&gt;studentdata.name,record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.num,record);      record = strtok(NULL, &quot;,&quot;);      q-&gt;studentdata.sex=atoi(record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.college,record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.major, record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.add, record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.tel,record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.QQ,record);      record = strtok(NULL, &quot;,&quot;);      strcpy(q-&gt;studentdata.email, record);      p-&gt;next=q;      p=q;  }  p-&gt;studentdata.email[strlen(q-&gt;studentdata.email)+1]=&#39;\0&#39;;  p-&gt;studentdata.email[strlen(q-&gt;studentdata.email)]=&#39;\n&#39;;  p-&gt;next=NULL;  fclose(fp);</code></pre><p>  }</p><p>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>           发送邮件             <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong>*</strong></strong></strong>                                  <strong><strong><strong><em>*</em></strong></strong></strong><br>  //<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>  void send(){<br>      fflush(stdin);<br>      cout&lt;&lt;”请输入同学姓名”&lt;<endl; cout<<"输入【1】返回主菜单"<<endl; char *name="(char*)malloc(NAMESIZE);" gets(name); node *p="head;" if (strcmp(name,"1")="=0)" { system("clear"); menu(); exit(1); } while (p) (strcmp(p->studentdata.name,name)==0) {<br>              break;<br>          }<br>          else{<br>              p=p-&gt;next;<br>          }<br>      }<br>      printsingle(p);<br>      free(name);<br>      sendto(p-&gt;studentdata.email);<br>      system(“clear”);<br>      cout&lt;&lt;”成功”&lt;&lt;endl;<br>      menu();<br>      exit(1);<br>  }</endl;></p><p>  void sendto(char *email)<br>  {<br>      printf(“1”);<br>      char body[] = “From: \”lucy\”<a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x31;&#49;&#57;&#x34;&#x37;&#57;&#x38;&#49;&#54;&#x30;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x31;&#49;&#57;&#x34;&#x37;&#57;&#x38;&#49;&#54;&#x30;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>\r\n”//这是我自己的邮箱<br>      “To: \”dasiy\”<a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x31;&#x31;&#57;&#x34;&#x37;&#x39;&#56;&#49;&#54;&#x30;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;">&#x31;&#x31;&#57;&#x34;&#x37;&#x39;&#56;&#49;&#54;&#x30;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a>\r\n”//也是我自己的<br>      “Subject: caution\r\n\r\n”//主题<br>      “Fail the test”;//内容<br>      sendemail(email, body);<br>  }</p><p>  char con628(char c6)<br>  {<br>      printf(“1”);<br>      char rtn = ‘\0’;<br>      if (c6 &lt; 26) rtn = c6 + 65;<br>      else if (c6 &lt; 52) rtn = c6 + 71;<br>      else if (c6 &lt; 62) rtn = c6 - 4;<br>      else if (c6 == 62) rtn = 43;<br>      else rtn = 47;<br>      return rtn;<br>  }</p><p>  // base64的实现<br>  void base64(char <em>dbuf, char </em>buf128, int len)<br>  {<br>      printf(“1”);<br>      struct data6 <em>ddd = NULL;<br>      int i = 0;<br>      char buf[256] = {0};<br>      char </em>tmp = NULL;<br>      char cc = ‘\0’;<br>      memset(buf, 0, 256);<br>      strcpy(buf, buf128);<br>      for(i = 1; i &lt;= len/3; i++)<br>      {<br>      tmp = buf+(i-1)<em>3;<br>      cc = tmp[2];<br>      tmp[2] = tmp[0];<br>      tmp[0] = cc;<br>      ddd = (struct data6 </em>)tmp;<br>      dbuf[(i-1)<em>4+0] = con628((unsigned int)ddd-&gt;d1);<br>      dbuf[(i-1)</em>4+1] = con628((unsigned int)ddd-&gt;d2);<br>      dbuf[(i-1)<em>4+2] = con628((unsigned int)ddd-&gt;d3);<br>      dbuf[(i-1)</em>4+3] = con628((unsigned int)ddd-&gt;d4);<br>      }<br>      if(len%3 == 1)<br>      {<br>      tmp = buf+(i-1)<em>3;<br>      cc = tmp[2];<br>      tmp[2] = tmp[0];<br>      tmp[0] = cc;<br>      ddd = (struct data6 </em>)tmp;<br>      dbuf[(i-1)<em>4+0] = con628((unsigned int)ddd-&gt;d1);<br>      dbuf[(i-1)</em>4+1] = con628((unsigned int)ddd-&gt;d2);<br>      dbuf[(i-1)<em>4+2] = ‘=’;<br>      dbuf[(i-1)</em>4+3] = ‘=’;<br>      }<br>      if(len%3 == 2)<br>      {<br>      tmp = buf+(i-1)<em>3;<br>      cc = tmp[2];<br>      tmp[2] = tmp[0];<br>      tmp[0] = cc;<br>      ddd = (struct data6 </em>)tmp;<br>      dbuf[(i-1)<em>4+0] = con628((unsigned int)ddd-&gt;d1);<br>      dbuf[(i-1)</em>4+1] = con628((unsigned int)ddd-&gt;d2);<br>      dbuf[(i-1)<em>4+2] = con628((unsigned int)ddd-&gt;d3);<br>      dbuf[(i-1)</em>4+3] = ‘=’;<br>      }<br>      return;<br>  }</p><p>  void sendemail(char <em>email, char </em>body)<br>  {<br>      printf(“1”);<br>      int sockfd = 0;<br>      struct sockaddr_in their_addr = {0};<br>      char buf[1500] = {0};<br>      char rbuf[1500] = {0};<br>      char login[128] = {0};<br>      char pass[128] = {0};<br>      memset(&amp;their_addr, 0, sizeof(their_addr));<br>      their_addr.sin_family = AF_INET;<br>      their_addr.sin_port = htons(25);<br>      their_addr.sin_addr.s_addr = inet_addr(“112.90.141.71”);//qq smtp 服务器<br>      // 连接邮件服务器，如果连接后没有响应，则2 秒后重新连接<br>      sockfd = open_socket((struct sockaddr <em>)&amp;their_addr);<br>      memset(rbuf,0,1500);<br>      while(recv(sockfd, rbuf, 1500, 0) == 0)<br>      {<br>          printf(“reconnect…\n”);<br>          sleep(2);<br>          //close(sockfd);<br>          sockfd = open_socket((struct sockaddr </em>)&amp;their_addr);</p><pre><code>      memset(rbuf,0,1500);  }  printf(&quot;%s\n&quot;, rbuf);  // EHLO  memset(buf, 0, 1500);  sprintf(buf, &quot;EHLO abcdefg-PC\r\n&quot;);  send(sockfd, buf, strlen(buf), 0);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  // AUTH LOGIN  memset(buf, 0, 1500);  sprintf(buf, &quot;AUTH LOGIN\r\n&quot;);  send(sockfd, buf, strlen(buf), 0);  printf(&quot;%s\n&quot;, buf);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  // USER  memset(buf, 0, 1500);  sprintf(buf,&quot;qq！！！！！！&quot;);//你的qq号  memset(login, 0, 128);  base64(login, buf, (int)strlen(buf));  sprintf(buf, &quot;%s\r\n&quot;, login);  send(sockfd, buf, strlen(buf), 0);  printf(&quot;%s\n&quot;, buf);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  // PASSWORD  sprintf(buf, &quot;密码！！！！&quot;);  memset(pass, 0, 128);  base64(pass, buf, (int)strlen(buf));  sprintf(buf, &quot;%s\r\n&quot;, pass);  send(sockfd, buf, strlen(buf), 0);  printf(&quot;%s\n&quot;, buf);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  // MAIL FROM  memset(buf, 0, 1500);  sprintf(buf, &quot;MAIL FROM: &lt;1194798160@qq.com&gt;\r\n&quot;);  send(sockfd, buf, strlen(buf), 0);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  // RCPT TO 第一个收件人  sprintf(buf, &quot;RCPT TO:&lt;%s&gt;\r\n&quot;, email);  send(sockfd, buf, strlen(buf), 0);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  // DATA 准备开始发送邮件内容  sprintf(buf, &quot;DATA\r\n&quot;);  send(sockfd, buf, strlen(buf), 0);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  // 发送邮件内容，\r\n.\r\n内容结束标记  sprintf(buf, &quot;%s\r\n.\r\n&quot;, body);  send(sockfd, buf, strlen(buf), 0);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  // QUIT  sprintf(buf, &quot;QUIT\r\n&quot;);  send(sockfd, buf, strlen(buf), 0);  memset(rbuf, 0, 1500);  recv(sockfd, rbuf, 1500, 0);  printf(&quot;%s\n&quot;, rbuf);  close(sockfd);  return;</code></pre><p>  }<br>      // 打开TCP Socket连接<br>  int open_socket(struct sockaddr *addr)<br>  {<br>      printf(“1”);<br>          int sockfd = 0;<br>          sockfd=socket(PF_INET, SOCK_STREAM, 0);<br>          if(sockfd &lt; 0)<br>          {<br>              fprintf(stderr, “Open sockfd(TCP) error!\n”);<br>              _exit(-1);<br>          }<br>          if(connect(sockfd, addr, sizeof(struct sockaddr)) &lt; 0)<br>          {<br>              fprintf(stderr, “Connect sockfd(TCP) error!\n”);<br>              _exit(-1);<br>          }<br>          return sockfd;<br>  }</p>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指针</tag>
      
      <tag>c语言</tag>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>课程设计</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言指针的应用</title>
    <link href="/2019/12/17/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2019/12/17/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>[行指针和列指针详解]<a href="https://blog.csdn.net/u013431550/article/details/43057537" target="_blank" rel="noopener">https://blog.csdn.net/u013431550/article/details/43057537</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>资源分享</tag>
      
      <tag>指针</tag>
      
      <tag>c语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(4)</title>
    <link href="/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-4/"/>
    <url>/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-4/</url>
    
    <content type="html"><![CDATA[<ul><li>验证 (Validation)</li><li>表示 (Representation)<a id="more"></a><h1 id="验证-Validation"><a href="#验证-Validation" class="headerlink" title="验证 (Validation)"></a>验证 (Validation)</h1><h2 id="更好的工作流程"><a href="#更好的工作流程" class="headerlink" title="更好的工作流程"></a>更好的工作流程</h2></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/WorkflowWithValidationSet.svg" srcset="/img/loading.gif" alt></li><li>在这一经过改进的工作流程中：<ul><li>选择在验证集上获得最佳效果的模型。</li><li>使用测试集再次检查该模型。</li><li>该工作流程之所以更好，原因在于它暴露给测试集的信息更少。<h1 id="表示-Representation"><a href="#表示-Representation" class="headerlink" title="表示 (Representation)"></a>表示 (Representation)</h1><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2></li></ul></li><li>机器学习模型不能直接看到、听到或感知输入样本。您必须创建数据表示，为模型提供有用的信号来了解数据的关键特性。也就是说，为了训练模型，您必须选择最能代表数据的特征集。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>machine learning</tag>
      
      <tag>python</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(3)</title>
    <link href="/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-3/"/>
    <url>/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-3/</url>
    
    <content type="html"><![CDATA[<ul><li>使用 TensorFlow 的起始步骤 (First Steps with TensorFlow)</li><li>泛化 (Generalization)</li><li>练集和测试集 (Training and Test Sets)<a id="more"></a><h1 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h1><h2 id="TensorFlow-工具包"><a href="#TensorFlow-工具包" class="headerlink" title="TensorFlow 工具包"></a>TensorFlow 工具包</h2></li><li><p><img src="https://developers.google.cn/machine-learning/crash-course/images/TFHierarchy.svg" srcset="/img/loading.gif" alt></p><h2 id="tf-estimator-API"><a href="#tf-estimator-API" class="headerlink" title="tf.estimator API"></a>tf.estimator API</h2><p>以下是在 tf.estimator 中实现的线性回归程序的格式：</p><p>  import tensorflow as tf</p><h1 id="Set-up-a-linear-classifier"><a href="#Set-up-a-linear-classifier" class="headerlink" title="Set up a linear classifier."></a>Set up a linear classifier.</h1><p>  classifier = tf.estimator.LinearClassifier()</p><h1 id="Train-the-model-on-some-example-data"><a href="#Train-the-model-on-some-example-data" class="headerlink" title="Train the model on some example data."></a>Train the model on some example data.</h1><p>  classifier.train(input_fn=train_input_fn, steps=2000)</p><h1 id="Use-it-to-predict"><a href="#Use-it-to-predict" class="headerlink" title="Use it to predict."></a>Use it to predict.</h1><p>  predictions = classifier.predict(input_fn=predict_input_fn)</p><h1 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化 (Generalization)"></a>泛化 (Generalization)</h1></li><li>泛化是指模型很好地拟合以前未见过的新数据（从用于创建该模型的同一分布中抽取）的能力。<h2 id="过拟合的风险"><a href="#过拟合的风险" class="headerlink" title="过拟合的风险"></a>过拟合的风险</h2></li><li><ul><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GeneralizationB.png" srcset="/img/loading.gif" alt></li><li>拟合</li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GeneralizationC.png" srcset="/img/loading.gif" alt></li><li>对比</li><li>损失很低，但仍然是糟糕的模型</li><li>过拟合是由于模型的复杂程度超出所需程度而造成的。机器学习的基本冲突是适当拟合我们的数据，但也要尽可能简单地拟合数据。<h2 id="奥卡姆剃刀定律"><a href="#奥卡姆剃刀定律" class="headerlink" title="奥卡姆剃刀定律"></a>奥卡姆剃刀定律</h2></li></ul></li><li><ul><li>奥卡姆的威廉是 14 世纪一位崇尚简单的修士和哲学家。他认为科学家应该优先采用更简单（而非更复杂）的公式或理论。</li><li>奥卡姆剃刀定律在机器学习方面的运用如下：<strong>机器学习模型越简单，良好的实证结果就越有可能不仅仅基于样本的特性。</strong></li><li><font color="red"> **如无必要，勿增实体** </font></li></ul></li><li>统计化描述模型根据以下因素泛化到新数据的能力：<ul><li>模型的复杂程度</li><li>模型在处理训练数据方面的表现</li></ul></li><li>据数据集构建模型，如何获得以前未见过的数据呢？一种方法是将您的数据集分成两个子集：<ul><li>训练集 - 用于训练模型的子集</li><li>测试集 - 用于测试模型的子集<h1 id="训练集和测试集-Training-and-Test-Sets"><a href="#训练集和测试集-Training-and-Test-Sets" class="headerlink" title="训练集和测试集 (Training and Test Sets)"></a>训练集和测试集 (Training and Test Sets)</h1><h2 id="拆分单个数据集"><a href="#拆分单个数据集" class="headerlink" title="拆分单个数据集"></a>拆分单个数据集</h2><img src="https://developers.google.cn/machine-learning/crash-course/images/PartitionTwoSets.svg" srcset="/img/loading.gif" alt><br><img src="https://developers.google.cn/machine-learning/crash-course/images/TrainingDataVsTestData.svg" srcset="/img/loading.gif" alt></li></ul></li><li>切勿训练测试数据</li><li>测试集应满足：<ul><li>能代表整个数据集。换言之，挑选的测试集的特征应该与训练集的特征相同。</li><li>规模足够大，可产生具有统计意义的结果</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>machine learning</tag>
      
      <tag>python</tag>
      
      <tag>算法</tag>
      
      <tag>TensorFlow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(2)</title>
    <link href="/2019/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-2/"/>
    <url>/2019/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-2/</url>
    
    <content type="html"><![CDATA[<p><strong>降低损失</strong></p><ul><li>迭代方法</li><li>梯度下降法</li><li>学习速率</li><li>优化学习速率</li><li>简单的练习<a id="more"></a><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2></li><li>hot and cold 游戏</li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GradientDescentDiagram.svg" srcset="/img/loading.gif" alt="迭代试错过程"></li><li><ul><li>初始值</li><li>计算损失</li><li>“计算参数更新”部分，机器学习系统就是在此部分检查损失函数的值，并为和生成新值。</li><li>学习过程会持续迭代，直到该算法发现损失可能最低的模型参数</li><li>不断迭代，直到总体损失不再变化或至少变化极其缓慢为止。这时候，我们可以说该模型已收敛。<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2></li></ul></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GradientDescentGradientStep.svg" srcset="/img/loading.gif" alt="碗状图"><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3></li><li>函数的梯度是偏导数相对于所有自变量的矢量</li><li><ul><li>z = f(x,y) 就像一个山谷，最低点为 (2,0,4)：的梯度是一个二维矢量，可让您了   解向哪个 (x,y) 方向移动时高度下降得最快。也就是说，梯度矢量指向山谷。</li><li>梯度是矢量：具有大小和方向</li><li>在机器学习中，梯度用于梯度下降法。我们的损失函数通常具有很多变量，而我们尝试通过跟随函数梯度的负方向来尽量降低损失函数。<br><img src="https://developers.google.cn/machine-learning/crash-course/images/ThreeDimensionalPlot.svg" srcset="/img/loading.gif" alt><h2 id="学习速率"><a href="#学习速率" class="headerlink" title="学习速率"></a>学习速率</h2></li></ul></li><li>每个回归问题都存在一个金发姑娘学习速率。“金发姑娘”值与损失函数的平坦程度相关。</li><li>学习速率过大：如果您知道损失函数的梯度较小，则可以放心地试着采用更大的学习速率，以补偿较小的梯度并获得更大的步长。<br>  <img src="https://developers.google.cn/machine-learning/crash-course/images/LearningRateTooLarge.svg" srcset="/img/loading.gif" alt></li><li>学习速率过小花费更多时间<br>  <img src="https://developers.google.cn/machine-learning/crash-course/images/LearningRateTooSmall.svg" srcset="/img/loading.gif" alt><h4 id="待理解和解决的问题"><a href="#待理解和解决的问题" class="headerlink" title="待理解和解决的问题"></a>待理解和解决的问题</h4></li><li>一维空间中的理想学习速率是（f(x) 对 x 的二阶导数的倒数）。</li><li>二维或多维空间中的理想学习速率是海森矩阵（由二阶偏导数组成的矩阵）的倒数。</li><li>广义凸函数的情况则更为复杂。<h2 id="优化学习速率"><a href="#优化学习速率" class="headerlink" title="优化学习速率"></a>优化学习速率</h2><a href="https://developers.google.cn/machine-learning/crash-course/fitter/graph" target="_blank" rel="noopener">playground</a><h2 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h2></li><li>通过从我们的数据集中<strong>随机选择样本</strong>，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，<strong>它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱</strong>。</li><li>批量指的是用于在单次迭代中计算梯度的样本总数</li><li>批量大小越大，出现冗余的可能性就越高。一些冗余可能有助于消除杂乱的梯度，但超大批量所具备的预测价值<strong>往往并不比大型批量高</strong>。</li><li>“随机”这一术语表示<strong>构成各个批量的一个样本都是随机选择的</strong>。<h2 id="Playground"><a href="#Playground" class="headerlink" title="Playground"></a>Playground</h2></li><li><strong>playground</strong>&gt;&gt;&gt;<a href="http://playground.tensorflow.org/" target="_blank" rel="noopener">http://playground.tensorflow.org/</a></li><li><a href="https://developers.google.cn/machine-learning/crash-course/reducing-loss/playground-exercise" target="_blank" rel="noopener">playround简介</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>machine learning</tag>
      
      <tag>python</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(1)</title>
    <link href="/2019/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-1/"/>
    <url>/2019/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-1/</url>
    
    <content type="html"><![CDATA[<ul><li>简介</li><li>框架处理</li><li>深入了解机器学习<a id="more"></a><h1 id="学习笔记：Machine-Learning-1"><a href="#学习笔记：Machine-Learning-1" class="headerlink" title="学习笔记：Machine Learning(1)"></a>学习笔记：Machine Learning(1)</h1></li><li>第一次接触machine learning</li><li>基于Google developer</li><li>参考<a href="https://developers.google.cn/machine-learning/crash-course" target="_blank" rel="noopener">https://developers.google.cn/machine-learning/crash-course</a><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2></li><li>由观察到统计而无需逻辑</li><li>最终延伸到自然科学</li><li>对大量样本<h2 id="问题构建"><a href="#问题构建" class="headerlink" title="问题构建"></a>问题构建</h2><h3 id="什么是（监督式）机器学习？"><a href="#什么是（监督式）机器学习？" class="headerlink" title="什么是（监督式）机器学习？"></a>什么是（监督式）机器学习？</h3></li><li>机器学习系统通过学习如何组合输入信息来对从未见过的数据做出有用的预测<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3></li><li>标签是我们要预测的事物，即简单线性回归中的 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3></li><li>特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征</li><li>在垃圾邮件检测器示例中，特征可能包括：<ul><li>电子邮件文本中的字词</li><li>发件人的地址</li><li>发送电子邮件的时段</li><li>电子邮件中包含“一种奇怪的把戏”这样的短语。<h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3></li></ul></li><li>样本是指数据的特定实例：<ul><li>有标签样本</li><li>无标签样本</li><li><ul><li><strong>我们使用有标签样本来训练模型。</strong>在垃圾邮件检测器中，有标签样本是用户明确标记为“垃圾邮件”或“非垃圾邮件”的各个电子邮件。</li><li><strong>在使用有标签样本训练模型之后，我们会使用该模型预测无标签样本的标签。</strong>在垃圾邮件检测器示例中，无标签样本是用户尚未添加标签的新电子邮件。</li></ul></li></ul></li><li><ul><li>labeled examples: {features, label}: (x, y) 有特征和标签<ul><li>例如房子的大小，房型，房间数；而房价则可称为标签；</li></ul></li><li>unlabeled examples: {features, ?}: (x, ?)  有特征而无标签<ul><li>房子大小房型知道，房价未知</li></ul></li></ul></li><li>个人理解：标签是更为主观的判断<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3></li><li>模型定义了特征与标签之间的关系。</li><li><strong>训练</strong>是指创建或学习模型。也就是说，向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。</li><li><strong>推断</strong>是指将训练后的模型应用于无标签样本。也就是说，使用经过训练的模型做出有用的预测 (y’)。例如，在推断期间，您可以针对新的无标签样本预测 medianHouseValue.<em>（即由房型，大小，房间数推断价格）</em><h3 id="回归与分类"><a href="#回归与分类" class="headerlink" title="回归与分类"></a>回归与分类</h3></li><li>回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题：<ul><li>加利福尼亚州一栋房产的价值是多少？</li><li>用户点击此广告的概率是多少？</li></ul></li><li>分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题：<ul><li>某个指定电子邮件是垃圾邮件还是非垃圾邮件？</li><li>这是一张狗、猫还是仓鼠图片？<h2 id="深入了解machin-learning"><a href="#深入了解machin-learning" class="headerlink" title="深入了解machin learning"></a>深入了解machin learning</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3></li></ul></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/CricketLine.svg" srcset="/img/loading.gif" alt="线性回归图"></li><li>即可简单的写出模型方程式<h3 id="训练与损失"><a href="#训练与损失" class="headerlink" title="训练与损失"></a>训练与损失</h3></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/LossSideBySide.png" srcset="/img/loading.gif" alt="1"></li><li>红色箭头表示损失,蓝线表示预测</li><li><strong>左侧模型的损失较大；右侧模型的损失较小</strong><h4 id="平方损失：一种常见的损失函数"><a href="#平方损失：一种常见的损失函数" class="headerlink" title="平方损失：一种常见的损失函数"></a>平方损失：一种常见的损失函数</h4>  = the square of the difference between the label and the prediction<br>  = (observation - prediction(x))2<br>  = (y - y’)2<h4 id="均方误差-MSE"><a href="#均方误差-MSE" class="headerlink" title="均方误差 (MSE)"></a>均方误差 (MSE)</h4></li><li>指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>machine learning</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于MATLAB的语音信号识别</title>
    <link href="/2019/12/02/%E5%9F%BA%E4%BA%8EMATLAB%E7%9A%84%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/"/>
    <url>/2019/12/02/%E5%9F%BA%E4%BA%8EMATLAB%E7%9A%84%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>在语音识别和话者识别方面，最常用到的语音特征就是梅尔倒谱系数（Mel-scaleFrequency Cepstral Coefficients，简称MFCC）。<br><a id="more"></a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul><li>本项目GitHub地址<a href="https://github.com/foresight100/matlab-.git" target="_blank" rel="noopener">https://github.com/foresight100/matlab-.git</a><h1 id="选择MFCC"><a href="#选择MFCC" class="headerlink" title="选择MFCC"></a>选择MFCC</h1></li><li>特征参数的好坏将直接影响系统的性能和效率，对特征参数的要求包括：</li><li><ul><li>(1)    提取的特征参数能有效地代表语音特征，具有很好的区分性；</li><li>(2)    各阶参数之间有良好的独立性；</li><li>(3)    特征参数要计算方便，最好有高效的计算方法，以保证语音识别的实时实现。</li></ul></li><li>LPCC的优点是计算量小，易于实现，对元音有较好的描述能力，<br>缺点是对辅音描述能力较差。</li><li><p>MFCC它响应不同频率信号的灵敏度是不同的，而Mel尺度倒谱系数能够比较充分利用人耳的这种特殊感知特性。</p></li><li><p>大量研究表明。MFCC系数能够比LPCC参数更好地提高系统的识别性能。</p></li></ul><h1 id="MAIN"><a href="#MAIN" class="headerlink" title="MAIN"></a>MAIN</h1><ul><li>语音特征MFCC提取过程<br><img src="http://static.oschina.net/uploads/space/2014/0115/164958_fSdw_852488.jpg" srcset="/img/loading.gif" alt="流程"></li><li>在语音识别和话者识别方面，最常用到的语音特征就是梅尔倒谱系数（Mel-scaleFrequency Cepstral Coefficients，简称MFCC）。</li><li>人耳对不同频率的声波有不同的听觉敏感度。从200Hz到5000Hz的语音信号对语音的清晰度影响对大。两个响度不等的声音作用于人耳时，则响度<strong>较高的频率成分的存在会影响到对响度较低</strong>的频率成分的感受，使其变得不易察觉，这种现象称为掩蔽效应。</li><li>由于频率较低的声音在内耳蜗基底膜上行波传递的距离大于频率较高的声音，故一般来说，低音容易掩蔽高音，而高音掩蔽低音较困难。在低频处的声音掩蔽的临界带宽较高频要小。</li><li>所以，<strong>人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征</strong>，对此特征经过进一步处理后就可以作为语音的输入特征。</li></ul><h2 id="语音信号预处理"><a href="#语音信号预处理" class="headerlink" title="语音信号预处理"></a>语音信号预处理</h2><h3 id="语音信号采集"><a href="#语音信号采集" class="headerlink" title="语音信号采集"></a>语音信号采集</h3><ul><li>可使用audiorecorder函数录制或由Windows的“录音机”程序录制成.wav文件然后使用audioread函数读入</li></ul><h3 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h3><ul><li>利用语音信号在短时间内频谱特性平稳的特点，将语音信号分为很小的时间段，即“帧”，来研究。我们的程序取帧长为256  ，帧移为80</li><li>简而言之，语音信号<font color="red"><strong>整体上不稳定，但局部上可以看作是稳定的</strong></font>,在以后的语音处理中，需要输入一个稳定的信号，所以需要对整个语音信号进行帧处理，即将其分割成多个片段。 </li><li>在10-30ms范围内，可以认为信号是稳定的。一般以不少于20毫秒为帧，约1/2的时间作为帧移位帧，帧移位是指相邻两帧之间的重叠区域，以避免相邻两帧的变化。</li></ul><h3 id="预加重"><a href="#预加重" class="headerlink" title="预加重"></a>预加重</h3><ul><li>将语音信号通过预加重滤波器来滤除低频干扰，而将对语音识别<font color="red"><strong>更为有用的高频部分</strong></font>进行频谱提升</li><li><strong>并不是在语音信号处理中任何时候都要进行预加重的</strong>，只有在需要提升高频分量时才进行预加重处理，例如共振峰提取时。</li><li><font color="red"> **往往高频信号含有更多的信息。**</font></li></ul><h3 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h3><ul><li><strong>加窗的目的就是让不太连续的地方（最后一个点和第一个的连接处）看上去平滑了，没有原来那么明显的突变了</strong></li><li>加窗有利于语音信号保持短时平稳性。在进行后续不同处理时选择窗口不同</li><li>函数窗的主要用于<font color="red"><strong>对截断处的不连续变化进行平滑，减少泄漏</strong>。</font>此外，加窗处理还有很多其它的原因，如减少噪声干扰、限定测试的持续时间、从频率接近的信号中分离出幅值不同的信号……</li><li><ul><li>在信号处理中，可以说加窗处理是一个必经的过程，因为我们的计算机只能处理有限长度的信号，因此原始信号X(t)要以T（采样时间）截断，即有限化，成为XT(t)后再进一步处理，这个过程序就是加窗处理，但什么时候用什么窗呢？</li><li>这时我们就要对所需用到的函数窗做一定的了解。在平时，我们用得最多的是矩形窗，这个也很容易理解，<font color="red"><strong>好像我们屋子里的窗口一样，透过窗口我们可以看到外面的世界，但在如果我们理窗口远一些的话，我们的看到的范围将减少，越远就越小</strong>。</font></li><li>实际的信号处理过程中，我们用的矩形窗，<strong>但矩形窗在边缘处将信号突然截断，窗外时域信息全部消失，导致在频域增加了频率分量的现象，即频谱泄漏</strong>。避免泄漏的最佳方法是满足整周期采样条件，但实际中是不可能做到的。</li><li>对于非整周期采样的情况，必须考虑如何减少加窗时造成的泄漏误差，主要的措施是使用合理的加窗函数，使信号截断的锐角钝化，从而使频谱的扩散减到最少。<h2 id="计算离散功率谱"><a href="#计算离散功率谱" class="headerlink" title="计算离散功率谱"></a>计算离散功率谱</h2></li></ul></li><li>信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察。对预处理的每帧进行离散傅立叶变换得到其频谱，再取模的平方作为离散功率<br>谱S(n)</li><li><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=c9f5c05add2a6059461de948495d5ffe/94cad1c8a786c917e7c47eaac33d70cf3ac75759.jpg" srcset="/img/loading.gif" alt="离散功率谱"></li><li><strong><font color="red">功率谱表示了信号功率随着频率的变化关系</font></strong><h2 id="将功率谱通过滤波器组"><a href="#将功率谱通过滤波器组" class="headerlink" title="将功率谱通过滤波器组"></a>将功率谱通过滤波器组</h2></li><li>MFCC考虑到了人类的听觉特征，先将线性频谱映射到基于听觉感知的Mel非线性频谱中，然后转换到倒谱上。<h2 id="取对数后做离散余弦变换"><a href="#取对数后做离散余弦变换" class="headerlink" title="取对数后做离散余弦变换"></a>取对数后做离散余弦变换</h2></li><li>在频谱图中，缓变信号和快变信号以乘积的方式耦合，所以取对数，使缓变信号和快变信号以相加的方式耦合。再取傅里叶逆变换，这样就能够将乘积变加法后的高频信号和低频信号的耦合分开来分析了<h2 id="动态差分系数的提取"><a href="#动态差分系数的提取" class="headerlink" title="动态差分系数的提取"></a>动态差分系数的提取</h2></li><li>标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分<br>谱来描述。通常会把动、静态特征结合起来以有效提高系统的识别性能。</li></ul><h2 id="加权与识别"><a href="#加权与识别" class="headerlink" title="加权与识别"></a>加权与识别</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><em><a href="https://www.ilovematlab.cn/thread-300509-1-1.html" target="_blank" rel="noopener">Matlab进行语音预加重处理</a></em></li><li><em><a href="https://blog.csdn.net/gxiaoyaya/article/details/73555195" target="_blank" rel="noopener">语音识别之——mfcc什么是汉明窗，为什么加汉明窗</a></em></li><li><em><a href="https://blog.csdn.net/liurong_cn/article/details/9812611" target="_blank" rel="noopener">基于DTW算法的语音识别原理与实现</a></em></li><li><em><a href="https://blog.csdn.net/jojozhangju/article/details/18678861" target="_blank" rel="noopener">语音特征MFCC提取过程详解</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>语音识别</tag>
      
      <tag>信息导论</tag>
      
      <tag>MFCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言中的排序方法</title>
    <link href="/2019/11/30/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <url>/2019/11/30/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><h3 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li><p>重复步骤1~3，直到排序完成。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void BubbleSort(int *arr, int size)    {        int i, j, tmp;        for (i = 0; i &lt; size - 1; i++) {            for (j = 0; j &lt; size - i - 1; j++) {                if (arr[j] &gt; arr[j+1]) {                    tmp = arr[j];                    arr[j] = arr[j+1];                    arr[j+1] = tmp;                }            }        }    }</code></pre></li></ul><h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h2><h3 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li><p>n-1趟结束，数组有序化了。</p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void SelectionSort(int *arr, int size)  {      int i, j, k, tmp;      for (i = 0; i &lt; size - 1; i++) {          k = i;          for (j = i + 1; j &lt; size; j++) {              if (arr[j] &lt; arr[k]) {                  k = j;              }          }          tmp = arr[k];          arr[k] = arr[i];          arr[i] = tmp;      }  }</code></pre></li></ul><h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><h3 id="算法描述：-2"><a href="#算法描述：-2" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li><p>重复步骤2~5。</p><h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void InsertionSort(int *arr, int size)      {          int i, j, tmp;          for (i = 1; i &lt; size; i++) {              if (arr[i] &lt; arr[i-1]) {                  tmp = arr[i];                  for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j--) {                    arr[j+1] = arr[j];                  }                arr[j+1] = tmp;              }                }      }</code></pre></li></ul><h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><h3 id="算法描述：-3"><a href="#算法描述：-3" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li><p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void ShellSort(int *arr, int size)    {        int i, j, tmp, increment;        for (increment = size/ 2; increment &gt; 0; increment /= 2) {              for (i = increment; i &lt; size; i++) {                tmp = arr[i];                for (j = i - increment; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= increment) {                    arr[j + increment] = arr[j];                }                arr[j + increment] = tmp;          }        }    }</code></pre></li></ul><h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h2><h3 id="算法描述：-4"><a href="#算法描述：-4" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li><p>将两个排序好的子序列合并成一个最终的排序序列。</p><h3 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  #define MAXSIZE 100    void Merge(int *SR, int *TR, int i, int middle, int rightend)   {      int j, k, l;        for (k = i, j = middle + 1; i &lt;= middle &amp;&amp; j &lt;= rightend; k++) {            if (SR[i] &lt; SR[j]) {              TR[k] = SR[i++];          } else {               TR[k] = SR[j++];          }        }        if (i &lt;= middle) {          for (l = 0; l &lt;= middle - i; l++) {              TR[k + l] = SR[i + l];          }        }        if (j &lt;= rightend) {          for (l = 0; l &lt;= rightend - j; l++) {              TR[k + l] = SR[j + l];            }      }    }    void MergeSort(int *SR, int *TR1, int s, int t)   {        int middle;        int TR2[MAXSIZE + 1];        if (s == t) {          TR1[s] = SR[s];       } else {            middle = (s + t) / 2;          MergeSort(SR, TR2, s, middle);          MergeSort(SR, TR2, middle + 1, t);          Merge(TR2, TR1, s, middle, t);      }    }</code></pre></li></ul><h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h2><h3 id="算法描述：-5"><a href="#算法描述：-5" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><h3 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void QuickSort(int *arr, int maxlen, int begin, int end)    {        int i, j;        if (begin &lt; end) {            i = begin + 1;            j = end;                  while (i &lt; j) {                if(arr[i] &gt; arr[begin]) {                    swap(&amp;arr[i], &amp;arr[j]);                   j--;                } else {                    i++;               }            }            if (arr[i] &gt;= arr[begin]) {                i--;            }            swap(&amp;arr[begin], &amp;arr[i]);                QuickSort(arr, maxlen, begin, i);            QuickSort(arr, maxlen, j, end);        }    }    void swap(int *a, int *b)      {        int temp;        temp = *a;        *a = *b;        *b = temp;    }</code></pre></li></ul><h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h2><h3 id="算法描述：-6"><a href="#算法描述：-6" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li><p>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><h3 id="代码实现：-6"><a href="#代码实现：-6" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void Heapify(int *arr, int m, int size)    {        int i, tmp;        tmp = arr[m];        for (i = 2 * m; i &lt;= size; i *= 2) {            if (i + 1 &lt;= size &amp;&amp; arr[i] &lt; arr[i+1]) {                i++;            }            if (arr[i] &lt; tmp) {                break;            }            arr[m] = arr[i];            m = i;        }        arr[m] = tmp;    }    void BulidHeap(int *arr, int size)  {        int i;        for (i = n / 2; i &gt; 0; i--) {            Heapify(arr, i, size);        }    }    void swap(int *arr, int i, int j)    {        int tmp;        tmp = arr[i];        arr[i] = arr[j];        arr[j] = tmp;    }    void HeapSort(int *arr, int size)    {        int i;        BulidHeap(arr, size);        for (i = size; i &gt; 1; i--) {            swap(arr, 1, i);          Heapify(arr, 1, i - 1);      }    }</code></pre></li></ul><h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h2><h3 id="算法描述：-7"><a href="#算法描述：-7" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p><h3 id="代码实现：-7"><a href="#代码实现：-7" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void CountingSort(int *A, int *B, int n, int k)    {        int *C = (int *)malloc(sizeof(int) * (k + 1));        int i;        for (i = 0; i &lt;= k; i++) {            C[i] = 0;        }        for (i = 0; i &lt; n; i++) {            C[A[i]]++;        }        for (i = 1; i &lt;= k; i++) {            C[i] = C[i] + C[i - 1];        }        for (i = n - 1; i &gt;= 0; i--) {            B[C[A[i]] - 1] = A[i];            C[A[i]]--;        }    }  </code></pre></li></ul><h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h2><h3 id="算法描述：-8"><a href="#算法描述：-8" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li><p>从不是空的桶里把排好序的数据拼接起来。</p><h3 id="代码实现：-8"><a href="#代码实现：-8" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void bucketSort(int *arr, int size, int max)  {      int i,j;      int buckets[max];      memset(buckets, 0, max * sizeof(int));      for (i = 0; i &lt; size; i++) {          buckets[arr[i]]++;       }      for (i = 0, j = 0; i &lt; max; i++) {          while((buckets[i]--) &gt;0)              arr[j++] = i;      }  }</code></pre></li></ul><h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h2><h3 id="算法描述：-9"><a href="#算法描述：-9" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h3 id="代码实现：-9"><a href="#代码实现：-9" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  int get_index(int num, int dec, int order)  {      int i, j, n;      int index;      int div;      for (i = dec; i &gt; order; i--) {          n = 1;          for (j = 0; j &lt; dec - 1; j++)              n *= 10;          div = num / n;          num -= div * n;          dec--;      }      n = 1;      for (i = 0; i &lt; order - 1; i++)          n *= 10;      index = num / n;      return index;  }  void RadixSort(int *arr, int len, int dec, int order)  {      int i, j;      int index;       int tmp[len];       int num[10];      memset(num, 0, 10 * sizeof(int));       memset(tmp, 0, len * sizeof(int));      if (dec &lt; order) {          return;      }      for (i = 0; i &lt; len; i++) {          index = get_index(arr[i], dec, order);          num[index]++;       }      for (i = 1; i &lt; 10; i++) {          num[i] += num[i-1];      }      for (i = len - 1; i &gt;= 0; i--) {          index = get_index(arr[i], dec, order);           j = --num[index];           tmp[j] = arr[i];       }      for (i = 0; i &lt; len; i++) {          arr[i] = tmp[i];       }      RadixSort(arr, len, dec, order+1);  }</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/11/30/hello-world/"/>
    <url>/2019/11/30/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="Do-not-just-seek-happiness-for-yourself-Seek-happiness-for-all-Through-kindness-Through-mercy"><a href="#Do-not-just-seek-happiness-for-yourself-Seek-happiness-for-all-Through-kindness-Through-mercy" class="headerlink" title="Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy."></a>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</h3><h4 id="David-Levithan"><a href="#David-Levithan" class="headerlink" title="David Levithan"></a>David Levithan</h4><h6 id="—Wide-Awake"><a href="#—Wide-Awake" class="headerlink" title="—Wide Awake"></a>—Wide Awake</h6>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
