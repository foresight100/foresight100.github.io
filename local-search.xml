<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学生通讯录管理系统（一次c语言的初步探索运用）</title>
    <link href="/2019/12/22/%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%E6%AC%A1c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%E8%BF%90%E7%94%A8%EF%BC%89/"/>
    <url>/2019/12/22/%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%E6%AC%A1c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%E8%BF%90%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>纪念人生第一次手撸2000行代码 (o^^o)♪<br><a id="more"></a><br><img src="https://i.loli.net/2019/12/22/AYRUeJpuT3DLiZP.jpg" srcset="/img/loading.gif" alt></p><h1 id="学生通讯录管理系统"><a href="#学生通讯录管理系统" class="headerlink" title="学生通讯录管理系统"></a>学生通讯录管理系统</h1><ul><li><strong>c语言课程设计</strong>  <h2 id="HUST-EIC"><a href="#HUST-EIC" class="headerlink" title="HUST EIC"></a>HUST EIC</h2></li></ul><h2 id="功能概述："><a href="#功能概述：" class="headerlink" title="功能概述："></a>功能概述：</h2><p>这是基于c语言的学生通讯录管理系统，包括以下功能：</p><ul><li><strong>导入csv等二进制格式文件</strong><ul><li>检测是否重复导入：若重复导入，提醒用户是否覆盖，或者回到主界面进行添加功能</li><li>检测文件是否存在：若存在则导入，若不存在会提示“NOT FOUND”重新导入</li></ul></li><li><strong>浏览所有学生信息</strong><ul><li>一键打印所有同学的所有信息</li></ul></li><li><strong>统计与查找所有学生信息</strong><ul><li>支持按各类特征查找，如：只查找名字或只查找学院，所有查找都支持模糊查找，如只输入姓氏，或只输入学院名称的几个字</li><li>支持关键字查找：输入关键字查找所有特征（即，把名字，学院，email等与关键字一一对比）</li><li>所有查找结果都返回查找的结果的个数</li><li>所有查找都支持模糊查找</li></ul></li><li><strong>排序</strong><ul><li>排序采用设标签法</li><li>设标签后，交换采用数据域的交换，而非结点的交换，有改进空间</li></ul></li><li><strong>删除学生信息</strong><ul><li>删除学生信息就是将该结点的上一级指针指向下一级，再free该结点</li><li>有避免误删的功能，即多次确定，且打印信息</li></ul></li><li><strong>添加新的学生信息</strong><ul><li>设计了两种添加学生信息的方式：<ul><li>用户手动添加</li><li>通过读取文件添加</li></ul></li><li>两种添加方式都直接添加在末尾</li></ul></li><li><strong>修改学生信息</strong><ul><li>根据学号的唯一性，通过学号找到学生本人然后进行修改。</li><li>同样具有容错性，例如：若查找不到学生，则打印 NOTFOUND！！</li></ul></li><li><strong>导出表格</strong><ul><li>输入导出表格的路径，若存在同名同路径文件，则覆盖，若不存在，则创建   </li></ul></li><li><strong>通知</strong><ul><li>base64加密和soket部分代码为网上demo，有些库函数不知osx和windows能否兼容<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><pre><code class="lang-mermaid">graph LRA[主界面] --&gt; B[导入文件]A[主界面] --&gt; C[排序]A[主界面] --&gt; D[浏览所有]A[主界面] --&gt; E[统计和查找]A[主界面] --&gt; F[添加新的学生信息]A[主界面] --&gt; G[修改学生信息]A[主界面] --&gt; H[删除学生信息]A[主界面] --&gt; I[导出]A[主界面] --&gt; J[通知学生]A[主界面] --&gt; K(退出程序)B--&gt;输入文件路径C--&gt;按姓名字典顺序排序C--&gt;按学号排序D--&gt;列表浏览所有学生信息E--&gt;5(统计与查找)5--&gt;按学号查找5--&gt;按名字查找5--&gt;按学院查找5--&gt;按地址查找5--&gt;按电话查找5--&gt;按邮箱查找F--&gt;手动添加F--&gt;文件添加G--&gt;查找--&gt;选择修改特征--&gt;键入修改后值--&gt;修改成功H--&gt;查找删除学生信息--&gt;1{确定删除}--&gt;删除I--&gt;选择输出路径--&gt;导出成功J--&gt;输入学生邮箱--&gt;send</code></pre><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2></li></ul></li><li><strong>结构采用一个功能一个模块（子函数），实现模块间的相互独立</strong></li><li><strong>存储数据的链表的表头是全局链表，可以不用传递参数便随时调取</strong></li><li><strong>进入功能后可以随时退出，回到主界面</strong></li><li><strong>所有模块都具有容错性</strong></li><li><strong>代码除「通知」模块的一部分，其他为纯手写</strong><h2 id="不足和改进空间"><a href="#不足和改进空间" class="headerlink" title="不足和改进空间"></a>不足和改进空间</h2></li><li>在统计和查找模块，可以利用定义函数来减少代码行数，但时间不足，暂来不及改变</li><li>结构还不够简洁</li><li>对学生信息的修改功能上，没有批量修改</li><li>对学生的信息统计能统计数目，暂不能有更多的统计功能</li><li>所有数据仅支持英文，中文在terminal中测试为乱码</li><li>发送通知的功能还需继续学习更多有关通信和加密的知识<h2 id="总结收获"><a href="#总结收获" class="headerlink" title="总结收获"></a>总结收获</h2></li><li>学会了链表的增删查改</li><li>学会了用c语言读写文件</li><li>对数组、指针、结构体的运用能力更近了一层</li><li>debug能力更强</li><li>初步接触套接字</li></ul>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>指针</tag>
      
      <tag>c语言</tag>
      
      <tag>课程设计</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言指针的应用</title>
    <link href="/2019/12/17/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2019/12/17/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>[行指针和列指针详解]<a href="https://blog.csdn.net/u013431550/article/details/43057537" target="_blank" rel="noopener">https://blog.csdn.net/u013431550/article/details/43057537</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>资源分享</tag>
      
      <tag>指针</tag>
      
      <tag>c语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(4)</title>
    <link href="/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-4/"/>
    <url>/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-4/</url>
    
    <content type="html"><![CDATA[<ul><li>验证 (Validation)</li><li>表示 (Representation)<a id="more"></a><h1 id="验证-Validation"><a href="#验证-Validation" class="headerlink" title="验证 (Validation)"></a>验证 (Validation)</h1><h2 id="更好的工作流程"><a href="#更好的工作流程" class="headerlink" title="更好的工作流程"></a>更好的工作流程</h2></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/WorkflowWithValidationSet.svg" srcset="/img/loading.gif" alt></li><li>在这一经过改进的工作流程中：<ul><li>选择在验证集上获得最佳效果的模型。</li><li>使用测试集再次检查该模型。</li><li>该工作流程之所以更好，原因在于它暴露给测试集的信息更少。<h1 id="表示-Representation"><a href="#表示-Representation" class="headerlink" title="表示 (Representation)"></a>表示 (Representation)</h1><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2></li></ul></li><li>机器学习模型不能直接看到、听到或感知输入样本。您必须创建数据表示，为模型提供有用的信号来了解数据的关键特性。也就是说，为了训练模型，您必须选择最能代表数据的特征集。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>机器学习</tag>
      
      <tag>machine learning</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(3)</title>
    <link href="/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-3/"/>
    <url>/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-3/</url>
    
    <content type="html"><![CDATA[<ul><li>使用 TensorFlow 的起始步骤 (First Steps with TensorFlow)</li><li>泛化 (Generalization)</li><li>练集和测试集 (Training and Test Sets)<a id="more"></a><h1 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h1><h2 id="TensorFlow-工具包"><a href="#TensorFlow-工具包" class="headerlink" title="TensorFlow 工具包"></a>TensorFlow 工具包</h2></li><li><p><img src="https://developers.google.cn/machine-learning/crash-course/images/TFHierarchy.svg" srcset="/img/loading.gif" alt></p><h2 id="tf-estimator-API"><a href="#tf-estimator-API" class="headerlink" title="tf.estimator API"></a>tf.estimator API</h2><p>以下是在 tf.estimator 中实现的线性回归程序的格式：</p><p>  import tensorflow as tf</p><h1 id="Set-up-a-linear-classifier"><a href="#Set-up-a-linear-classifier" class="headerlink" title="Set up a linear classifier."></a>Set up a linear classifier.</h1><p>  classifier = tf.estimator.LinearClassifier()</p><h1 id="Train-the-model-on-some-example-data"><a href="#Train-the-model-on-some-example-data" class="headerlink" title="Train the model on some example data."></a>Train the model on some example data.</h1><p>  classifier.train(input_fn=train_input_fn, steps=2000)</p><h1 id="Use-it-to-predict"><a href="#Use-it-to-predict" class="headerlink" title="Use it to predict."></a>Use it to predict.</h1><p>  predictions = classifier.predict(input_fn=predict_input_fn)</p><h1 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化 (Generalization)"></a>泛化 (Generalization)</h1></li><li>泛化是指模型很好地拟合以前未见过的新数据（从用于创建该模型的同一分布中抽取）的能力。<h2 id="过拟合的风险"><a href="#过拟合的风险" class="headerlink" title="过拟合的风险"></a>过拟合的风险</h2></li><li><ul><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GeneralizationB.png" srcset="/img/loading.gif" alt></li><li>拟合</li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GeneralizationC.png" srcset="/img/loading.gif" alt></li><li>对比</li><li>损失很低，但仍然是糟糕的模型</li><li>过拟合是由于模型的复杂程度超出所需程度而造成的。机器学习的基本冲突是适当拟合我们的数据，但也要尽可能简单地拟合数据。<h2 id="奥卡姆剃刀定律"><a href="#奥卡姆剃刀定律" class="headerlink" title="奥卡姆剃刀定律"></a>奥卡姆剃刀定律</h2></li></ul></li><li><ul><li>奥卡姆的威廉是 14 世纪一位崇尚简单的修士和哲学家。他认为科学家应该优先采用更简单（而非更复杂）的公式或理论。</li><li>奥卡姆剃刀定律在机器学习方面的运用如下：<strong>机器学习模型越简单，良好的实证结果就越有可能不仅仅基于样本的特性。</strong></li><li><font color="red"> **如无必要，勿增实体** </font></li></ul></li><li>统计化描述模型根据以下因素泛化到新数据的能力：<ul><li>模型的复杂程度</li><li>模型在处理训练数据方面的表现</li></ul></li><li>据数据集构建模型，如何获得以前未见过的数据呢？一种方法是将您的数据集分成两个子集：<ul><li>训练集 - 用于训练模型的子集</li><li>测试集 - 用于测试模型的子集<h1 id="训练集和测试集-Training-and-Test-Sets"><a href="#训练集和测试集-Training-and-Test-Sets" class="headerlink" title="训练集和测试集 (Training and Test Sets)"></a>训练集和测试集 (Training and Test Sets)</h1><h2 id="拆分单个数据集"><a href="#拆分单个数据集" class="headerlink" title="拆分单个数据集"></a>拆分单个数据集</h2><img src="https://developers.google.cn/machine-learning/crash-course/images/PartitionTwoSets.svg" srcset="/img/loading.gif" alt><br><img src="https://developers.google.cn/machine-learning/crash-course/images/TrainingDataVsTestData.svg" srcset="/img/loading.gif" alt></li></ul></li><li>切勿训练测试数据</li><li>测试集应满足：<ul><li>能代表整个数据集。换言之，挑选的测试集的特征应该与训练集的特征相同。</li><li>规模足够大，可产生具有统计意义的结果</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>机器学习</tag>
      
      <tag>machine learning</tag>
      
      <tag>python</tag>
      
      <tag>TensorFlow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(2)</title>
    <link href="/2019/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-2/"/>
    <url>/2019/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-2/</url>
    
    <content type="html"><![CDATA[<p><strong>降低损失</strong></p><ul><li>迭代方法</li><li>梯度下降法</li><li>学习速率</li><li>优化学习速率</li><li>简单的练习<a id="more"></a><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2></li><li>hot and cold 游戏</li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GradientDescentDiagram.svg" srcset="/img/loading.gif" alt="迭代试错过程"></li><li><ul><li>初始值</li><li>计算损失</li><li>“计算参数更新”部分，机器学习系统就是在此部分检查损失函数的值，并为和生成新值。</li><li>学习过程会持续迭代，直到该算法发现损失可能最低的模型参数</li><li>不断迭代，直到总体损失不再变化或至少变化极其缓慢为止。这时候，我们可以说该模型已收敛。<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2></li></ul></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GradientDescentGradientStep.svg" srcset="/img/loading.gif" alt="碗状图"><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3></li><li>函数的梯度是偏导数相对于所有自变量的矢量</li><li><ul><li>z = f(x,y) 就像一个山谷，最低点为 (2,0,4)：的梯度是一个二维矢量，可让您了   解向哪个 (x,y) 方向移动时高度下降得最快。也就是说，梯度矢量指向山谷。</li><li>梯度是矢量：具有大小和方向</li><li>在机器学习中，梯度用于梯度下降法。我们的损失函数通常具有很多变量，而我们尝试通过跟随函数梯度的负方向来尽量降低损失函数。<br><img src="https://developers.google.cn/machine-learning/crash-course/images/ThreeDimensionalPlot.svg" srcset="/img/loading.gif" alt><h2 id="学习速率"><a href="#学习速率" class="headerlink" title="学习速率"></a>学习速率</h2></li></ul></li><li>每个回归问题都存在一个金发姑娘学习速率。“金发姑娘”值与损失函数的平坦程度相关。</li><li>学习速率过大：如果您知道损失函数的梯度较小，则可以放心地试着采用更大的学习速率，以补偿较小的梯度并获得更大的步长。<br>  <img src="https://developers.google.cn/machine-learning/crash-course/images/LearningRateTooLarge.svg" srcset="/img/loading.gif" alt></li><li>学习速率过小花费更多时间<br>  <img src="https://developers.google.cn/machine-learning/crash-course/images/LearningRateTooSmall.svg" srcset="/img/loading.gif" alt><h4 id="待理解和解决的问题"><a href="#待理解和解决的问题" class="headerlink" title="待理解和解决的问题"></a>待理解和解决的问题</h4></li><li>一维空间中的理想学习速率是（f(x) 对 x 的二阶导数的倒数）。</li><li>二维或多维空间中的理想学习速率是海森矩阵（由二阶偏导数组成的矩阵）的倒数。</li><li>广义凸函数的情况则更为复杂。<h2 id="优化学习速率"><a href="#优化学习速率" class="headerlink" title="优化学习速率"></a>优化学习速率</h2><a href="https://developers.google.cn/machine-learning/crash-course/fitter/graph" target="_blank" rel="noopener">playground</a><h2 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h2></li><li>通过从我们的数据集中<strong>随机选择样本</strong>，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，<strong>它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱</strong>。</li><li>批量指的是用于在单次迭代中计算梯度的样本总数</li><li>批量大小越大，出现冗余的可能性就越高。一些冗余可能有助于消除杂乱的梯度，但超大批量所具备的预测价值<strong>往往并不比大型批量高</strong>。</li><li>“随机”这一术语表示<strong>构成各个批量的一个样本都是随机选择的</strong>。<h2 id="Playground"><a href="#Playground" class="headerlink" title="Playground"></a>Playground</h2></li><li><strong>playground</strong>&gt;&gt;&gt;<a href="http://playground.tensorflow.org/" target="_blank" rel="noopener">http://playground.tensorflow.org/</a></li><li><a href="https://developers.google.cn/machine-learning/crash-course/reducing-loss/playground-exercise" target="_blank" rel="noopener">playround简介</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>机器学习</tag>
      
      <tag>machine learning</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(1)</title>
    <link href="/2019/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-1/"/>
    <url>/2019/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-1/</url>
    
    <content type="html"><![CDATA[<ul><li>简介</li><li>框架处理</li><li>深入了解机器学习<a id="more"></a><h1 id="学习笔记：Machine-Learning-1"><a href="#学习笔记：Machine-Learning-1" class="headerlink" title="学习笔记：Machine Learning(1)"></a>学习笔记：Machine Learning(1)</h1></li><li>第一次接触machine learning</li><li>基于Google developer</li><li>参考<a href="https://developers.google.cn/machine-learning/crash-course" target="_blank" rel="noopener">https://developers.google.cn/machine-learning/crash-course</a><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2></li><li>由观察到统计而无需逻辑</li><li>最终延伸到自然科学</li><li>对大量样本<h2 id="问题构建"><a href="#问题构建" class="headerlink" title="问题构建"></a>问题构建</h2><h3 id="什么是（监督式）机器学习？"><a href="#什么是（监督式）机器学习？" class="headerlink" title="什么是（监督式）机器学习？"></a>什么是（监督式）机器学习？</h3></li><li>机器学习系统通过学习如何组合输入信息来对从未见过的数据做出有用的预测<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3></li><li>标签是我们要预测的事物，即简单线性回归中的 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3></li><li>特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征</li><li>在垃圾邮件检测器示例中，特征可能包括：<ul><li>电子邮件文本中的字词</li><li>发件人的地址</li><li>发送电子邮件的时段</li><li>电子邮件中包含“一种奇怪的把戏”这样的短语。<h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3></li></ul></li><li>样本是指数据的特定实例：<ul><li>有标签样本</li><li>无标签样本</li><li><ul><li><strong>我们使用有标签样本来训练模型。</strong>在垃圾邮件检测器中，有标签样本是用户明确标记为“垃圾邮件”或“非垃圾邮件”的各个电子邮件。</li><li><strong>在使用有标签样本训练模型之后，我们会使用该模型预测无标签样本的标签。</strong>在垃圾邮件检测器示例中，无标签样本是用户尚未添加标签的新电子邮件。</li></ul></li></ul></li><li><ul><li>labeled examples: {features, label}: (x, y) 有特征和标签<ul><li>例如房子的大小，房型，房间数；而房价则可称为标签；</li></ul></li><li>unlabeled examples: {features, ?}: (x, ?)  有特征而无标签<ul><li>房子大小房型知道，房价未知</li></ul></li></ul></li><li>个人理解：标签是更为主观的判断<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3></li><li>模型定义了特征与标签之间的关系。</li><li><strong>训练</strong>是指创建或学习模型。也就是说，向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。</li><li><strong>推断</strong>是指将训练后的模型应用于无标签样本。也就是说，使用经过训练的模型做出有用的预测 (y’)。例如，在推断期间，您可以针对新的无标签样本预测 medianHouseValue.<em>（即由房型，大小，房间数推断价格）</em><h3 id="回归与分类"><a href="#回归与分类" class="headerlink" title="回归与分类"></a>回归与分类</h3></li><li>回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题：<ul><li>加利福尼亚州一栋房产的价值是多少？</li><li>用户点击此广告的概率是多少？</li></ul></li><li>分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题：<ul><li>某个指定电子邮件是垃圾邮件还是非垃圾邮件？</li><li>这是一张狗、猫还是仓鼠图片？<h2 id="深入了解machin-learning"><a href="#深入了解machin-learning" class="headerlink" title="深入了解machin learning"></a>深入了解machin learning</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3></li></ul></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/CricketLine.svg" srcset="/img/loading.gif" alt="线性回归图"></li><li>即可简单的写出模型方程式<h3 id="训练与损失"><a href="#训练与损失" class="headerlink" title="训练与损失"></a>训练与损失</h3></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/LossSideBySide.png" srcset="/img/loading.gif" alt="1"></li><li>红色箭头表示损失,蓝线表示预测</li><li><strong>左侧模型的损失较大；右侧模型的损失较小</strong><h4 id="平方损失：一种常见的损失函数"><a href="#平方损失：一种常见的损失函数" class="headerlink" title="平方损失：一种常见的损失函数"></a>平方损失：一种常见的损失函数</h4>  = the square of the difference between the label and the prediction<br>  = (observation - prediction(x))2<br>  = (y - y’)2<h4 id="均方误差-MSE"><a href="#均方误差-MSE" class="headerlink" title="均方误差 (MSE)"></a>均方误差 (MSE)</h4></li><li>指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>machine learning</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于MATLAB的语音信号识别</title>
    <link href="/2019/12/02/%E5%9F%BA%E4%BA%8EMATLAB%E7%9A%84%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/"/>
    <url>/2019/12/02/%E5%9F%BA%E4%BA%8EMATLAB%E7%9A%84%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>在语音识别和话者识别方面，最常用到的语音特征就是梅尔倒谱系数（Mel-scaleFrequency Cepstral Coefficients，简称MFCC）。<br><a id="more"></a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul><li>本项目GitHub地址<a href="https://github.com/foresight100/matlab-.git" target="_blank" rel="noopener">https://github.com/foresight100/matlab-.git</a><h1 id="选择MFCC"><a href="#选择MFCC" class="headerlink" title="选择MFCC"></a>选择MFCC</h1></li><li>特征参数的好坏将直接影响系统的性能和效率，对特征参数的要求包括：</li><li><ul><li>(1)    提取的特征参数能有效地代表语音特征，具有很好的区分性；</li><li>(2)    各阶参数之间有良好的独立性；</li><li>(3)    特征参数要计算方便，最好有高效的计算方法，以保证语音识别的实时实现。</li></ul></li><li>LPCC的优点是计算量小，易于实现，对元音有较好的描述能力，<br>缺点是对辅音描述能力较差。</li><li><p>MFCC它响应不同频率信号的灵敏度是不同的，而Mel尺度倒谱系数能够比较充分利用人耳的这种特殊感知特性。</p></li><li><p>大量研究表明。MFCC系数能够比LPCC参数更好地提高系统的识别性能。</p></li></ul><h1 id="MAIN"><a href="#MAIN" class="headerlink" title="MAIN"></a>MAIN</h1><ul><li>语音特征MFCC提取过程<br><img src="http://static.oschina.net/uploads/space/2014/0115/164958_fSdw_852488.jpg" srcset="/img/loading.gif" alt="流程"></li><li>在语音识别和话者识别方面，最常用到的语音特征就是梅尔倒谱系数（Mel-scaleFrequency Cepstral Coefficients，简称MFCC）。</li><li>人耳对不同频率的声波有不同的听觉敏感度。从200Hz到5000Hz的语音信号对语音的清晰度影响对大。两个响度不等的声音作用于人耳时，则响度<strong>较高的频率成分的存在会影响到对响度较低</strong>的频率成分的感受，使其变得不易察觉，这种现象称为掩蔽效应。</li><li>由于频率较低的声音在内耳蜗基底膜上行波传递的距离大于频率较高的声音，故一般来说，低音容易掩蔽高音，而高音掩蔽低音较困难。在低频处的声音掩蔽的临界带宽较高频要小。</li><li>所以，<strong>人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征</strong>，对此特征经过进一步处理后就可以作为语音的输入特征。</li></ul><h2 id="语音信号预处理"><a href="#语音信号预处理" class="headerlink" title="语音信号预处理"></a>语音信号预处理</h2><h3 id="语音信号采集"><a href="#语音信号采集" class="headerlink" title="语音信号采集"></a>语音信号采集</h3><ul><li>可使用audiorecorder函数录制或由Windows的“录音机”程序录制成.wav文件然后使用audioread函数读入</li></ul><h3 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h3><ul><li>利用语音信号在短时间内频谱特性平稳的特点，将语音信号分为很小的时间段，即“帧”，来研究。我们的程序取帧长为256  ，帧移为80</li><li>简而言之，语音信号<font color="red"><strong>整体上不稳定，但局部上可以看作是稳定的</strong></font>,在以后的语音处理中，需要输入一个稳定的信号，所以需要对整个语音信号进行帧处理，即将其分割成多个片段。 </li><li>在10-30ms范围内，可以认为信号是稳定的。一般以不少于20毫秒为帧，约1/2的时间作为帧移位帧，帧移位是指相邻两帧之间的重叠区域，以避免相邻两帧的变化。</li></ul><h3 id="预加重"><a href="#预加重" class="headerlink" title="预加重"></a>预加重</h3><ul><li>将语音信号通过预加重滤波器来滤除低频干扰，而将对语音识别<font color="red"><strong>更为有用的高频部分</strong></font>进行频谱提升</li><li><strong>并不是在语音信号处理中任何时候都要进行预加重的</strong>，只有在需要提升高频分量时才进行预加重处理，例如共振峰提取时。</li><li><font color="red"> **往往高频信号含有更多的信息。**</font></li></ul><h3 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h3><ul><li><strong>加窗的目的就是让不太连续的地方（最后一个点和第一个的连接处）看上去平滑了，没有原来那么明显的突变了</strong></li><li>加窗有利于语音信号保持短时平稳性。在进行后续不同处理时选择窗口不同</li><li>函数窗的主要用于<font color="red"><strong>对截断处的不连续变化进行平滑，减少泄漏</strong>。</font>此外，加窗处理还有很多其它的原因，如减少噪声干扰、限定测试的持续时间、从频率接近的信号中分离出幅值不同的信号……</li><li><ul><li>在信号处理中，可以说加窗处理是一个必经的过程，因为我们的计算机只能处理有限长度的信号，因此原始信号X(t)要以T（采样时间）截断，即有限化，成为XT(t)后再进一步处理，这个过程序就是加窗处理，但什么时候用什么窗呢？</li><li>这时我们就要对所需用到的函数窗做一定的了解。在平时，我们用得最多的是矩形窗，这个也很容易理解，<font color="red"><strong>好像我们屋子里的窗口一样，透过窗口我们可以看到外面的世界，但在如果我们理窗口远一些的话，我们的看到的范围将减少，越远就越小</strong>。</font></li><li>实际的信号处理过程中，我们用的矩形窗，<strong>但矩形窗在边缘处将信号突然截断，窗外时域信息全部消失，导致在频域增加了频率分量的现象，即频谱泄漏</strong>。避免泄漏的最佳方法是满足整周期采样条件，但实际中是不可能做到的。</li><li>对于非整周期采样的情况，必须考虑如何减少加窗时造成的泄漏误差，主要的措施是使用合理的加窗函数，使信号截断的锐角钝化，从而使频谱的扩散减到最少。<h2 id="计算离散功率谱"><a href="#计算离散功率谱" class="headerlink" title="计算离散功率谱"></a>计算离散功率谱</h2></li></ul></li><li>信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察。对预处理的每帧进行离散傅立叶变换得到其频谱，再取模的平方作为离散功率<br>谱S(n)</li><li><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=c9f5c05add2a6059461de948495d5ffe/94cad1c8a786c917e7c47eaac33d70cf3ac75759.jpg" srcset="/img/loading.gif" alt="离散功率谱"></li><li><strong><font color="red">功率谱表示了信号功率随着频率的变化关系</font></strong><h2 id="将功率谱通过滤波器组"><a href="#将功率谱通过滤波器组" class="headerlink" title="将功率谱通过滤波器组"></a>将功率谱通过滤波器组</h2></li><li>MFCC考虑到了人类的听觉特征，先将线性频谱映射到基于听觉感知的Mel非线性频谱中，然后转换到倒谱上。<h2 id="取对数后做离散余弦变换"><a href="#取对数后做离散余弦变换" class="headerlink" title="取对数后做离散余弦变换"></a>取对数后做离散余弦变换</h2></li><li>在频谱图中，缓变信号和快变信号以乘积的方式耦合，所以取对数，使缓变信号和快变信号以相加的方式耦合。再取傅里叶逆变换，这样就能够将乘积变加法后的高频信号和低频信号的耦合分开来分析了<h2 id="动态差分系数的提取"><a href="#动态差分系数的提取" class="headerlink" title="动态差分系数的提取"></a>动态差分系数的提取</h2></li><li>标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分<br>谱来描述。通常会把动、静态特征结合起来以有效提高系统的识别性能。</li></ul><h2 id="加权与识别"><a href="#加权与识别" class="headerlink" title="加权与识别"></a>加权与识别</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><em><a href="https://www.ilovematlab.cn/thread-300509-1-1.html" target="_blank" rel="noopener">Matlab进行语音预加重处理</a></em></li><li><em><a href="https://blog.csdn.net/gxiaoyaya/article/details/73555195" target="_blank" rel="noopener">语音识别之——mfcc什么是汉明窗，为什么加汉明窗</a></em></li><li><em><a href="https://blog.csdn.net/liurong_cn/article/details/9812611" target="_blank" rel="noopener">基于DTW算法的语音识别原理与实现</a></em></li><li><em><a href="https://blog.csdn.net/jojozhangju/article/details/18678861" target="_blank" rel="noopener">语音特征MFCC提取过程详解</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>语音识别</tag>
      
      <tag>信息导论</tag>
      
      <tag>MFCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言中的排序方法</title>
    <link href="/2019/11/30/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <url>/2019/11/30/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><h3 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li><p>重复步骤1~3，直到排序完成。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void BubbleSort(int *arr, int size)    {        int i, j, tmp;        for (i = 0; i &lt; size - 1; i++) {            for (j = 0; j &lt; size - i - 1; j++) {                if (arr[j] &gt; arr[j+1]) {                    tmp = arr[j];                    arr[j] = arr[j+1];                    arr[j+1] = tmp;                }            }        }    }</code></pre></li></ul><h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h2><h3 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li><p>n-1趟结束，数组有序化了。</p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void SelectionSort(int *arr, int size)  {      int i, j, k, tmp;      for (i = 0; i &lt; size - 1; i++) {          k = i;          for (j = i + 1; j &lt; size; j++) {              if (arr[j] &lt; arr[k]) {                  k = j;              }          }          tmp = arr[k];          arr[k] = arr[i];          arr[i] = tmp;      }  }</code></pre></li></ul><h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><h3 id="算法描述：-2"><a href="#算法描述：-2" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li><p>重复步骤2~5。</p><h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void InsertionSort(int *arr, int size)      {          int i, j, tmp;          for (i = 1; i &lt; size; i++) {              if (arr[i] &lt; arr[i-1]) {                  tmp = arr[i];                  for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j--) {                    arr[j+1] = arr[j];                  }                arr[j+1] = tmp;              }                }      }</code></pre></li></ul><h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><h3 id="算法描述：-3"><a href="#算法描述：-3" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li><p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void ShellSort(int *arr, int size)    {        int i, j, tmp, increment;        for (increment = size/ 2; increment &gt; 0; increment /= 2) {              for (i = increment; i &lt; size; i++) {                tmp = arr[i];                for (j = i - increment; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= increment) {                    arr[j + increment] = arr[j];                }                arr[j + increment] = tmp;          }        }    }</code></pre></li></ul><h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h2><h3 id="算法描述：-4"><a href="#算法描述：-4" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li><p>将两个排序好的子序列合并成一个最终的排序序列。</p><h3 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  #define MAXSIZE 100    void Merge(int *SR, int *TR, int i, int middle, int rightend)   {      int j, k, l;        for (k = i, j = middle + 1; i &lt;= middle &amp;&amp; j &lt;= rightend; k++) {            if (SR[i] &lt; SR[j]) {              TR[k] = SR[i++];          } else {               TR[k] = SR[j++];          }        }        if (i &lt;= middle) {          for (l = 0; l &lt;= middle - i; l++) {              TR[k + l] = SR[i + l];          }        }        if (j &lt;= rightend) {          for (l = 0; l &lt;= rightend - j; l++) {              TR[k + l] = SR[j + l];            }      }    }    void MergeSort(int *SR, int *TR1, int s, int t)   {        int middle;        int TR2[MAXSIZE + 1];        if (s == t) {          TR1[s] = SR[s];       } else {            middle = (s + t) / 2;          MergeSort(SR, TR2, s, middle);          MergeSort(SR, TR2, middle + 1, t);          Merge(TR2, TR1, s, middle, t);      }    }</code></pre></li></ul><h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h2><h3 id="算法描述：-5"><a href="#算法描述：-5" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><h3 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void QuickSort(int *arr, int maxlen, int begin, int end)    {        int i, j;        if (begin &lt; end) {            i = begin + 1;            j = end;                  while (i &lt; j) {                if(arr[i] &gt; arr[begin]) {                    swap(&amp;arr[i], &amp;arr[j]);                   j--;                } else {                    i++;               }            }            if (arr[i] &gt;= arr[begin]) {                i--;            }            swap(&amp;arr[begin], &amp;arr[i]);                QuickSort(arr, maxlen, begin, i);            QuickSort(arr, maxlen, j, end);        }    }    void swap(int *a, int *b)      {        int temp;        temp = *a;        *a = *b;        *b = temp;    }</code></pre></li></ul><h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h2><h3 id="算法描述：-6"><a href="#算法描述：-6" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li><p>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><h3 id="代码实现：-6"><a href="#代码实现：-6" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void Heapify(int *arr, int m, int size)    {        int i, tmp;        tmp = arr[m];        for (i = 2 * m; i &lt;= size; i *= 2) {            if (i + 1 &lt;= size &amp;&amp; arr[i] &lt; arr[i+1]) {                i++;            }            if (arr[i] &lt; tmp) {                break;            }            arr[m] = arr[i];            m = i;        }        arr[m] = tmp;    }    void BulidHeap(int *arr, int size)  {        int i;        for (i = n / 2; i &gt; 0; i--) {            Heapify(arr, i, size);        }    }    void swap(int *arr, int i, int j)    {        int tmp;        tmp = arr[i];        arr[i] = arr[j];        arr[j] = tmp;    }    void HeapSort(int *arr, int size)    {        int i;        BulidHeap(arr, size);        for (i = size; i &gt; 1; i--) {            swap(arr, 1, i);          Heapify(arr, 1, i - 1);      }    }</code></pre></li></ul><h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h2><h3 id="算法描述：-7"><a href="#算法描述：-7" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p><h3 id="代码实现：-7"><a href="#代码实现：-7" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void CountingSort(int *A, int *B, int n, int k)    {        int *C = (int *)malloc(sizeof(int) * (k + 1));        int i;        for (i = 0; i &lt;= k; i++) {            C[i] = 0;        }        for (i = 0; i &lt; n; i++) {            C[A[i]]++;        }        for (i = 1; i &lt;= k; i++) {            C[i] = C[i] + C[i - 1];        }        for (i = n - 1; i &gt;= 0; i--) {            B[C[A[i]] - 1] = A[i];            C[A[i]]--;        }    }  </code></pre></li></ul><h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h2><h3 id="算法描述：-8"><a href="#算法描述：-8" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li><p>从不是空的桶里把排好序的数据拼接起来。</p><h3 id="代码实现：-8"><a href="#代码实现：-8" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void bucketSort(int *arr, int size, int max)  {      int i,j;      int buckets[max];      memset(buckets, 0, max * sizeof(int));      for (i = 0; i &lt; size; i++) {          buckets[arr[i]]++;       }      for (i = 0, j = 0; i &lt; max; i++) {          while((buckets[i]--) &gt;0)              arr[j++] = i;      }  }</code></pre></li></ul><h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h2><h3 id="算法描述：-9"><a href="#算法描述：-9" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h3 id="代码实现：-9"><a href="#代码实现：-9" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  int get_index(int num, int dec, int order)  {      int i, j, n;      int index;      int div;      for (i = dec; i &gt; order; i--) {          n = 1;          for (j = 0; j &lt; dec - 1; j++)              n *= 10;          div = num / n;          num -= div * n;          dec--;      }      n = 1;      for (i = 0; i &lt; order - 1; i++)          n *= 10;      index = num / n;      return index;  }  void RadixSort(int *arr, int len, int dec, int order)  {      int i, j;      int index;       int tmp[len];       int num[10];      memset(num, 0, 10 * sizeof(int));       memset(tmp, 0, len * sizeof(int));      if (dec &lt; order) {          return;      }      for (i = 0; i &lt; len; i++) {          index = get_index(arr[i], dec, order);          num[index]++;       }      for (i = 1; i &lt; 10; i++) {          num[i] += num[i-1];      }      for (i = len - 1; i &gt;= 0; i--) {          index = get_index(arr[i], dec, order);           j = --num[index];           tmp[j] = arr[i];       }      for (i = 0; i &lt; len; i++) {          arr[i] = tmp[i];       }      RadixSort(arr, len, dec, order+1);  }</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/11/30/hello-world/"/>
    <url>/2019/11/30/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="Do-not-just-seek-happiness-for-yourself-Seek-happiness-for-all-Through-kindness-Through-mercy"><a href="#Do-not-just-seek-happiness-for-yourself-Seek-happiness-for-all-Through-kindness-Through-mercy" class="headerlink" title="Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy."></a>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</h3><h4 id="David-Levithan"><a href="#David-Levithan" class="headerlink" title="David Levithan"></a>David Levithan</h4><h6 id="—Wide-Awake"><a href="#—Wide-Awake" class="headerlink" title="—Wide Awake"></a>—Wide Awake</h6>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
