<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于MATLAB的语音信号识别</title>
    <link href="undefined2019/12/02/%E5%9F%BA%E4%BA%8EMATLAB%E7%9A%84%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/"/>
    <url>2019/12/02/%E5%9F%BA%E4%BA%8EMATLAB%E7%9A%84%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="语音信号预处理"><a href="#语音信号预处理" class="headerlink" title="语音信号预处理"></a>语音信号预处理</h2><h3 id="语音信号采集"><a href="#语音信号采集" class="headerlink" title="语音信号采集"></a>语音信号采集</h3><ul><li>可使用audiorecorder函数录制或由Windows的“录音机”程序录制成.wav文件然后使用audioread函数读入</li></ul><h3 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h3><ul><li>利用语音信号在短时间内频谱特性平稳的特点，将语音信号分为很小的时间段，即“帧”，来研究。我们的程序取帧长为256  ，帧移为80</li><li>简而言之，语音信号<strong>整体上不稳定，但局部上可以看作是稳定的</strong>,在以后的语音处理中，需要输入一个稳定的信号，所以需要对整个语音信号进行帧处理，即将其分割成多个片段。 </li><li>在10-30ms范围内，可以认为信号是稳定的。一般以不少于20毫秒为帧，约1/2的时间作为帧移位帧，帧移位是指相邻两帧之间的重叠区域，以避免相邻两帧的变化。<br>![]（/img/matlabrecognize/1.png)</li></ul><h3 id="预加重"><a href="#预加重" class="headerlink" title="预加重"></a>预加重</h3><ul><li>将语音信号通过预加重滤波器来滤除低频干扰，而将对语音识别<strong>更为有用的高频部分</strong>进行频谱提升</li><li><strong>并不是在语音信号处理中任何时候都要进行预加重的</strong>，只有在需要提升高频分量时才进行预加重处理，例如共振峰提取时。</li><li><font color='red'> <strong>往往高频信号含有更多的信息。</strong></font><br>![]（/img/matlabrecognize/2.png)</li></ul><h3 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h3><ul><li>加窗有利于语音信号保持短时平稳性。在进行后续不同处理时选择窗口不同</li><li>函数窗的主要用于<strong>对截断处的不连续变化进行平滑，减少泄漏</strong>。此外，加窗处理还有很多其它的原因，如减少噪声干扰、限定测试的持续时间、从频率接近的信号中分离出幅值不同的信号……</li><li><ul><li>在信号处理中，可以说加窗处理是一个必经的过程，因为我们的计算机只能处理有限长度的信号，因此原始信号X(t)要以T（采样时间）截断，即有限化，成为XT(t)后再进一步处理，这个过程序就是加窗处理，但什么时候用什么窗呢？</li><li>这时我们就要对所需用到的函数窗做一定的了解。在平时，我们用得最多的是矩形窗，这个也很容易理解，<strong>好像我们屋子里的窗口一样，透过窗口我们可以看到外面的世界，但在如果我们理窗口远一些的话，我们的看到的范围将减少，越远就越小</strong>。</li><li>实际的信号处理过程中，我们用的矩形窗，<strong>但矩形窗在边缘处将信号突然截断，窗外时域信息全部消失，导致在频域增加了频率分量的现象，即频谱泄漏</strong>。避免泄漏的最佳方法是满足整周期采样条件，但实际中是不可能做到的。</li><li>对于非整周期采样的情况，必须考虑如何减少加窗时造成的泄漏误差，主要的措施是使用合理的加窗函数，使信号截断的锐角钝化，从而使频谱的扩散减到最少。<br>![]（/img/matlabrecognize/3.png)</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><em><a href="https://www.ilovematlab.cn/thread-300509-1-1.html" target="_blank" rel="noopener">Matlab进行语音预加重处理</a></em></li><li><em><a href="https://blog.csdn.net/gxiaoyaya/article/details/73555195" target="_blank" rel="noopener">语音识别之——mfcc什么是汉明窗，为什么加汉明窗</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>语音识别</tag>
      
      <tag>信息导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言中的排序方法</title>
    <link href="undefined2019/11/30/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <url>2019/11/30/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><h3 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li><p>重复步骤1~3，直到排序完成。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void BubbleSort(int *arr, int size)    {        int i, j, tmp;        for (i = 0; i &lt; size - 1; i++) {            for (j = 0; j &lt; size - i - 1; j++) {                if (arr[j] &gt; arr[j+1]) {                    tmp = arr[j];                    arr[j] = arr[j+1];                    arr[j+1] = tmp;                }            }        }    }</code></pre></li></ul><h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h2><h3 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li><p>n-1趟结束，数组有序化了。</p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void SelectionSort(int *arr, int size)  {      int i, j, k, tmp;      for (i = 0; i &lt; size - 1; i++) {          k = i;          for (j = i + 1; j &lt; size; j++) {              if (arr[j] &lt; arr[k]) {                  k = j;              }          }          tmp = arr[k];          arr[k] = arr[i];          arr[i] = tmp;      }  }</code></pre></li></ul><h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><h3 id="算法描述：-2"><a href="#算法描述：-2" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li><p>重复步骤2~5。</p><h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void InsertionSort(int *arr, int size)      {          int i, j, tmp;          for (i = 1; i &lt; size; i++) {              if (arr[i] &lt; arr[i-1]) {                  tmp = arr[i];                  for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j--) {                    arr[j+1] = arr[j];                  }                arr[j+1] = tmp;              }                }      }</code></pre></li></ul><h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><h3 id="算法描述：-3"><a href="#算法描述：-3" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li><p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void ShellSort(int *arr, int size)    {        int i, j, tmp, increment;        for (increment = size/ 2; increment &gt; 0; increment /= 2) {              for (i = increment; i &lt; size; i++) {                tmp = arr[i];                for (j = i - increment; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= increment) {                    arr[j + increment] = arr[j];                }                arr[j + increment] = tmp;          }        }    }</code></pre></li></ul><h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h2><h3 id="算法描述：-4"><a href="#算法描述：-4" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li><p>将两个排序好的子序列合并成一个最终的排序序列。</p><h3 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  #define MAXSIZE 100    void Merge(int *SR, int *TR, int i, int middle, int rightend)   {      int j, k, l;        for (k = i, j = middle + 1; i &lt;= middle &amp;&amp; j &lt;= rightend; k++) {            if (SR[i] &lt; SR[j]) {              TR[k] = SR[i++];          } else {               TR[k] = SR[j++];          }        }        if (i &lt;= middle) {          for (l = 0; l &lt;= middle - i; l++) {              TR[k + l] = SR[i + l];          }        }        if (j &lt;= rightend) {          for (l = 0; l &lt;= rightend - j; l++) {              TR[k + l] = SR[j + l];            }      }    }    void MergeSort(int *SR, int *TR1, int s, int t)   {        int middle;        int TR2[MAXSIZE + 1];        if (s == t) {          TR1[s] = SR[s];       } else {            middle = (s + t) / 2;          MergeSort(SR, TR2, s, middle);          MergeSort(SR, TR2, middle + 1, t);          Merge(TR2, TR1, s, middle, t);      }    }</code></pre></li></ul><h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h2><h3 id="算法描述：-5"><a href="#算法描述：-5" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><h3 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void QuickSort(int *arr, int maxlen, int begin, int end)    {        int i, j;        if (begin &lt; end) {            i = begin + 1;            j = end;                  while (i &lt; j) {                if(arr[i] &gt; arr[begin]) {                    swap(&amp;arr[i], &amp;arr[j]);                   j--;                } else {                    i++;               }            }            if (arr[i] &gt;= arr[begin]) {                i--;            }            swap(&amp;arr[begin], &amp;arr[i]);                QuickSort(arr, maxlen, begin, i);            QuickSort(arr, maxlen, j, end);        }    }    void swap(int *a, int *b)      {        int temp;        temp = *a;        *a = *b;        *b = temp;    }</code></pre></li></ul><h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h2><h3 id="算法描述：-6"><a href="#算法描述：-6" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li><p>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><h3 id="代码实现：-6"><a href="#代码实现：-6" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void Heapify(int *arr, int m, int size)    {        int i, tmp;        tmp = arr[m];        for (i = 2 * m; i &lt;= size; i *= 2) {            if (i + 1 &lt;= size &amp;&amp; arr[i] &lt; arr[i+1]) {                i++;            }            if (arr[i] &lt; tmp) {                break;            }            arr[m] = arr[i];            m = i;        }        arr[m] = tmp;    }    void BulidHeap(int *arr, int size)  {        int i;        for (i = n / 2; i &gt; 0; i--) {            Heapify(arr, i, size);        }    }    void swap(int *arr, int i, int j)    {        int tmp;        tmp = arr[i];        arr[i] = arr[j];        arr[j] = tmp;    }    void HeapSort(int *arr, int size)    {        int i;        BulidHeap(arr, size);        for (i = size; i &gt; 1; i--) {            swap(arr, 1, i);          Heapify(arr, 1, i - 1);      }    }</code></pre></li></ul><h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h2><h3 id="算法描述：-7"><a href="#算法描述：-7" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p><h3 id="代码实现：-7"><a href="#代码实现：-7" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void CountingSort(int *A, int *B, int n, int k)    {        int *C = (int *)malloc(sizeof(int) * (k + 1));        int i;        for (i = 0; i &lt;= k; i++) {            C[i] = 0;        }        for (i = 0; i &lt; n; i++) {            C[A[i]]++;        }        for (i = 1; i &lt;= k; i++) {            C[i] = C[i] + C[i - 1];        }        for (i = n - 1; i &gt;= 0; i--) {            B[C[A[i]] - 1] = A[i];            C[A[i]]--;        }    }  </code></pre></li></ul><h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h2><h3 id="算法描述：-8"><a href="#算法描述：-8" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li><p>从不是空的桶里把排好序的数据拼接起来。</p><h3 id="代码实现：-8"><a href="#代码实现：-8" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void bucketSort(int *arr, int size, int max)  {      int i,j;      int buckets[max];      memset(buckets, 0, max * sizeof(int));      for (i = 0; i &lt; size; i++) {          buckets[arr[i]]++;       }      for (i = 0, j = 0; i &lt; max; i++) {          while((buckets[i]--) &gt;0)              arr[j++] = i;      }  }</code></pre></li></ul><h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h2><h3 id="算法描述：-9"><a href="#算法描述：-9" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h3 id="代码实现：-9"><a href="#代码实现：-9" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  int get_index(int num, int dec, int order)  {      int i, j, n;      int index;      int div;      for (i = dec; i &gt; order; i--) {          n = 1;          for (j = 0; j &lt; dec - 1; j++)              n *= 10;          div = num / n;          num -= div * n;          dec--;      }      n = 1;      for (i = 0; i &lt; order - 1; i++)          n *= 10;      index = num / n;      return index;  }  void RadixSort(int *arr, int len, int dec, int order)  {      int i, j;      int index;       int tmp[len];       int num[10];      memset(num, 0, 10 * sizeof(int));       memset(tmp, 0, len * sizeof(int));      if (dec &lt; order) {          return;      }      for (i = 0; i &lt; len; i++) {          index = get_index(arr[i], dec, order);          num[index]++;       }      for (i = 1; i &lt; 10; i++) {          num[i] += num[i-1];      }      for (i = len - 1; i &gt;= 0; i--) {          index = get_index(arr[i], dec, order);           j = --num[index];           tmp[j] = arr[i];       }      for (i = 0; i &lt; len; i++) {          arr[i] = tmp[i];       }      RadixSort(arr, len, dec, order+1);  }</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/11/30/hello-world/"/>
    <url>2019/11/30/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="Do-not-just-seek-happiness-for-yourself-Seek-happiness-for-all-Through-kindness-Through-mercy"><a href="#Do-not-just-seek-happiness-for-yourself-Seek-happiness-for-all-Through-kindness-Through-mercy" class="headerlink" title="Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy."></a>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</h3><h4 id="David-Levithan"><a href="#David-Levithan" class="headerlink" title="David Levithan"></a>David Levithan</h4><h6 id="—Wide-Awake"><a href="#—Wide-Awake" class="headerlink" title="—Wide Awake"></a>—Wide Awake</h6>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>