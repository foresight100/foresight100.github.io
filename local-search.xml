<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于概率论的分类方法：朴素贝叶斯</title>
    <link href="/2020/06/02/%E5%9F%BA%E4%BA%8E%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <url>/2020/06/02/%E5%9F%BA%E4%BA%8E%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="基于贝叶斯决策理论的分类方法"><a href="#基于贝叶斯决策理论的分类方法" class="headerlink" title="基于贝叶斯决策理论的分类方法"></a>基于贝叶斯决策理论的分类方法</h2><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><ul><li>优点：在数据较少的情况下仍然有效，可以处理多类别问题</li><li>缺点：对于输入数据的准备方式较为敏感</li><li>适用数据类型：标称型数据</li></ul><h3 id="贝叶斯决策理论"><a href="#贝叶斯决策理论" class="headerlink" title="贝叶斯决策理论"></a>贝叶斯决策理论</h3><ul><li>核心思想：选择具有最高概率的决策</li><li>p1(x,y) &gt; p2(x,y) 则为类别1</li><li>p1(x,y) &lt; p2(x,y) 则为类别2</li></ul><h3 id="Bayes准则"><a href="#Bayes准则" class="headerlink" title="Bayes准则"></a>Bayes准则</h3><ul><li><p>一元：P(A∩B) = P(A)<em>P(B|A)=P(B)</em>P(A|B)如上公式也可变形为：P(A|B)=P(B|A)*P(A)/P(B)。</p></li><li><p>二元：p(c|x,y) = p(x,y|c)*p(c)/p(x,y)</p></li></ul><h2 id="使用朴素贝叶斯进行文档分类"><a href="#使用朴素贝叶斯进行文档分类" class="headerlink" title="使用朴素贝叶斯进行文档分类"></a>使用朴素贝叶斯进行文档分类</h2><ul><li><strong>准备数据</strong></li></ul><pre><code class="hljs python"><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> *</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 测试用数据</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadDataSet</span><span class="hljs-params">()</span>:</span>    postingList=[[<span class="hljs-string">'my'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'has'</span>, <span class="hljs-string">'flea'</span>, <span class="hljs-string">'problems'</span>, <span class="hljs-string">'help'</span>, <span class="hljs-string">'please'</span>],[<span class="hljs-string">'maybe'</span>, <span class="hljs-string">'not'</span>, <span class="hljs-string">'take'</span>, <span class="hljs-string">'him'</span>, <span class="hljs-string">'to'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'park'</span>, <span class="hljs-string">'stupid'</span>],[<span class="hljs-string">'my'</span>, <span class="hljs-string">'dalmation'</span>, <span class="hljs-string">'is'</span>, <span class="hljs-string">'so'</span>, <span class="hljs-string">'cute'</span>, <span class="hljs-string">'I'</span>, <span class="hljs-string">'love'</span>, <span class="hljs-string">'him'</span>],[<span class="hljs-string">'stop'</span>, <span class="hljs-string">'posting'</span>, <span class="hljs-string">'stupid'</span>, <span class="hljs-string">'worthless'</span>, <span class="hljs-string">'garbage'</span>],[<span class="hljs-string">'mr'</span>, <span class="hljs-string">'licks'</span>, <span class="hljs-string">'ate'</span>, <span class="hljs-string">'my'</span>, <span class="hljs-string">'steak'</span>, <span class="hljs-string">'how'</span>, <span class="hljs-string">'to'</span>, <span class="hljs-string">'stop'</span>, <span class="hljs-string">'him'</span>],[<span class="hljs-string">'quit'</span>, <span class="hljs-string">'buying'</span>, <span class="hljs-string">'worthless'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'food'</span>, <span class="hljs-string">'stupid'</span>]]    <span class="hljs-comment"># 1表示含侮辱性词，0表示不含</span>    classVec = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]    <span class="hljs-comment">#1 is abusive, 0 not</span>    <span class="hljs-comment"># 返回词条矩阵和标记向量</span>    <span class="hljs-keyword">return</span> postingList,classVec</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 求词条的并集，也就是将所有单词不重复的添加到一个数组中</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createVocabList</span><span class="hljs-params">(dataSet)</span>:</span>  <span class="hljs-comment"># 建空集，一个一个添加进去，最后返回</span>    vocabSet = set([])  <span class="hljs-comment">#create empty set</span>    <span class="hljs-keyword">for</span> document <span class="hljs-keyword">in</span> dataSet:      <span class="hljs-comment"># ｜求并集,不重复的将单词加入数组</span>        vocabSet = vocabSet | set(document) <span class="hljs-comment">#union of the two sets</span>    <span class="hljs-keyword">return</span> list(vocabSet)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 输入词汇表和某个文档，作用是检测文档中的单词在词汇表中是否出现，并返回向量</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setOfWords2Vec</span><span class="hljs-params">(vocabList, inputSet)</span>:</span>  <span class="hljs-comment"># 词汇表等长0向量</span>    returnVec = [<span class="hljs-number">0</span>]*len(vocabList)    <span class="hljs-comment"># 遍历文档</span>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> inputSet:      <span class="hljs-comment"># 若文档中单词在词汇表中存在</span>        <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> vocabList:          <span class="hljs-comment"># 向量相应位置为1</span>            returnVec[vocabList.index(word)] = <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>: <span class="hljs-keyword">print</span> <span class="hljs-string">"the word: %s is not in my Vocabulary!"</span> % word    <span class="hljs-keyword">return</span> returnVec</code></pre><ul><li><strong>训练算法</strong>：朴素贝叶斯分类器</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 传入对于每个句子的词汇表是否存在的向量，向量和词汇表一样长；以及标记的句子是否含侮辱性词汇</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trainNB0</span><span class="hljs-params">(trainMatrix,trainCategory)</span>:</span>   <span class="hljs-comment"># 句子个数</span>   numTrainDocs = len(trainMatrix)   <span class="hljs-comment"># 词汇表长度</span>   numWords = len(trainMatrix[<span class="hljs-number">0</span>])   <span class="hljs-comment"># 属于侮辱性文档概率</span>   pAbusive = sum(trainCategory)/float(numTrainDocs)      <span class="hljs-comment"># 将p初始化为1/2的目的是防止概率乘积为0</span>   p0Num = ones(numWords); p1Num = ones(numWords)<span class="hljs-comment">#单位向量 </span>   p0Denom = <span class="hljs-number">2.0</span>; p1Denom = <span class="hljs-number">2.0</span>                 <span class="hljs-comment">#p初始化为1/2</span>      <span class="hljs-comment"># 对于每个句子</span>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(numTrainDocs):     <span class="hljs-comment"># 如果这个句子被标有含侮辱性</span>       <span class="hljs-keyword">if</span> trainCategory[i] == <span class="hljs-number">1</span>:         <span class="hljs-comment"># 侮辱性句子的词汇向量</span>           p1Num += trainMatrix[i]           <span class="hljs-comment"># 侮辱性句子的词汇数</span>           p1Denom += sum(trainMatrix[i])      <span class="hljs-comment"># 句子被标为正常</span>       <span class="hljs-keyword">else</span>:         <span class="hljs-comment"># 正常句子的词汇向量</span>           p0Num += trainMatrix[i]           <span class="hljs-comment"># 正常句子的词汇数</span>           p0Denom += sum(trainMatrix[i])   <span class="hljs-comment"># 对于侮辱性句子的每一个词汇/侮辱性句子的词汇数</span>   <span class="hljs-comment"># log避免下溢出或者被舍掉，p的乘积可以转化为对数加法</span>   p1Vect = log(p1Num/p1Denom)          <span class="hljs-comment">#change to log()</span>   <span class="hljs-comment"># 正常句子同上</span>   p0Vect = log(p0Num/p0Denom)          <span class="hljs-comment">#change to log()</span>   <span class="hljs-keyword">return</span> p0Vect,p1Vect,pAbusive <span class="hljs-comment"># 可以大致知道哪一个词为侮辱性词</span></code></pre><ul><li><strong>测试算法</strong></li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classifyNB</span><span class="hljs-params">(vec2Classify, p0Vec, p1Vec, pClass1)</span>:</span>  <span class="hljs-comment"># 乘法是对应位置元素相乘</span>  <span class="hljs-comment"># 做过乘法后将每个元素相加加到该类别的对数概率上</span>    p1 = sum(vec2Classify * p1Vec) + log(pClass1)    p0 = sum(vec2Classify * p0Vec) + log(<span class="hljs-number">1.0</span> - pClass1)     <span class="hljs-comment"># 依据贝叶斯决策论返回结果</span>    <span class="hljs-keyword">if</span> p1 &gt; p0:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre><pre><code class="hljs python"><span class="hljs-comment"># 封装好的测试算法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testingNB</span><span class="hljs-params">()</span>:</span>  <span class="hljs-comment"># 构造训练集</span>    listOPosts,listClasses = loadDataSet()    <span class="hljs-comment"># 求的词汇表</span>    myVocabList = createVocabList(listOPosts)    trainMat=[]    <span class="hljs-comment"># 每个句子的词汇表向量</span>    <span class="hljs-keyword">for</span> postinDoc <span class="hljs-keyword">in</span> listOPosts:        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))    <span class="hljs-comment"># 每个类别的对应的词汇的出现概率和这个文档是否为侮辱性文档</span>    p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses))        <span class="hljs-comment"># 测试集（正常句子）</span>    testEntry = [<span class="hljs-string">'love'</span>, <span class="hljs-string">'my'</span>, <span class="hljs-string">'dalmation'</span>]    <span class="hljs-comment"># 测试集对应的词汇表向量</span>    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))    <span class="hljs-comment"># 打印结果</span>    <span class="hljs-keyword">print</span> testEntry,<span class="hljs-string">'classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb)    <span class="hljs-comment"># 打印结果</span>        <span class="hljs-comment"># 测试集（侮辱性句子）</span>    testEntry = [<span class="hljs-string">'stupid'</span>, <span class="hljs-string">'garbage'</span>]    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))    <span class="hljs-keyword">print</span> testEntry,<span class="hljs-string">'classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb)</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> payesbayes.testingNB()output:[<span class="hljs-string">'love'</span>, <span class="hljs-string">'my'</span>, <span class="hljs-string">'dalmation'</span>] classified <span class="hljs-keyword">as</span>:  <span class="hljs-number">0</span>[<span class="hljs-string">'stupid'</span>, <span class="hljs-string">'garbage'</span>] classified <span class="hljs-keyword">as</span>:  <span class="hljs-number">1</span></code></pre><h2 id="实战应用：使用朴素贝叶斯过滤垃圾邮件"><a href="#实战应用：使用朴素贝叶斯过滤垃圾邮件" class="headerlink" title="实战应用：使用朴素贝叶斯过滤垃圾邮件"></a>实战应用：使用朴素贝叶斯过滤垃圾邮件</h2><ul><li><p>训练算法：已经构建的trainNB()</p><p>测试算法：classifyNB(),并构建新测试集</p></li><li><p><strong>准备数据</strong>：切分文本</p><p>用python.split类似Java(String.split())</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MachineLearningInAction</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>k-近邻算法</title>
    <link href="/2020/05/20/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/20/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>采用测量不同特征值之间的距离方法进行分类</li><li>优点：精度高、异常值不敏感、无数据输入假定</li><li>缺点：复杂度高</li><li>适用：数值型、标称型</li></ul><h2 id="准备与实现"><a href="#准备与实现" class="headerlink" title="准备与实现"></a>准备与实现</h2><ul><li><p>kNN步骤</p><ul><li>计算已知类别数据集中点和当前点的距离</li><li>按照距离递增次序排列</li><li>选取与当前点距离最小的k个点</li><li>确定前k个点所在类别的出现频率</li><li>返回出现最高的类别作为当前类别</li></ul></li><li><pre><code class="lang-python"># kNNdef classify0(inX, dataSet, labels, k):    dataSetSize = dataSet.shape[0]    # 计算距离    diffMat = tile(inX, (dataSetSize,1)) - dataSet    sqDiffMat = diffMat**2    sqDistances = sqDiffMat.sum(axis=1) #欧式距离公式    distances = sqDistances**0.5    sortedDistIndicies = distances.argsort() #返回排序索引    # 选择距离最小的点    classCount={}              for i in range(k):        voteIlabel = labels[sortedDistIndicies[i]]        classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1    # 排序    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)    #返回类    return sortedClassCount[0][0]</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>MachineLearningInAction</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>retrofit</title>
    <link href="/2020/05/18/retrofit/"/>
    <url>/2020/05/18/retrofit/</url>
    
    <content type="html"><![CDATA[<p><img src="https:////upload-images.jianshu.io/upload_images/944365-2bd80b234ae9d155.png?imageMogr2/auto-orient/strip|imageView2/2/w/1124" srcset="/img/loading.gif" alt="img"></p><ul><li><pre><code class="lang-java">public class Translation {        private int status;    private content content;    private static class content {        private String from;        private String to;        private String vendor;        private String out;        private int errNo;    }    //定义 输出返回数据 的方法    public void show() {        System.out.println(status);        System.out.println(content.from);        System.out.println(content.to);        System.out.println(content.vendor);        System.out.println(content.out);        System.out.println(content.errNo);    }}</code></pre><p><img src="https:////upload-images.jianshu.io/upload_images/944365-38b09dee149d5e63.png?imageMogr2/auto-orient/strip|imageView2/2/w/1114" srcset="/img/loading.gif" alt="img"></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>随机森林RandomForst</title>
    <link href="/2020/05/15/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97RandomForst/"/>
    <url>/2020/05/15/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97RandomForst/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/05/15/OIyu69zjivF4tH1.jpg" srcset="/img/loading.gif" alt="005ZSIdEly1gerci95ue7j30a4057aai.jpg"></p><ul><li><p>python语言随机森林</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> decision_tree.decision_tree_model  <span class="hljs-keyword">import</span> ClassificationTree<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomForest</span><span class="hljs-params">()</span>:</span>    <span class="hljs-string">"""Random Forest classifier. Uses a collection of classification trees that    trains on random subsets of the data using a random subsets of the features.    Parameters:    -----------    n_estimators: int        树的数量        The number of classification trees that are used.    max_features: int        每棵树选用数据集中的最大的特征数        The maximum number of features that the classification trees are allowed to        use.    min_samples_split: int        每棵树中最小的分割数，比如 min_samples_split = 2表示树切到还剩下两个数据集时就停止        The minimum number of samples needed to make a split when building a tree.    min_gain: float        每棵树切到小于min_gain后停止        The minimum impurity required to split the tree further.    max_depth: int        每棵树的最大层数        The maximum depth of a tree.    """</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n_estimators=<span class="hljs-number">100</span>, min_samples_split=<span class="hljs-number">2</span>, min_gain=<span class="hljs-number">0</span>,                 max_depth=float<span class="hljs-params">(<span class="hljs-string">"inf"</span>)</span>, max_features=None)</span>:</span>        self.n_estimators = n_estimators        self.min_samples_split = min_samples_split        self.min_gain = min_gain        self.max_depth = max_depth        self.max_features = max_features        self.trees = []        <span class="hljs-comment"># 建立森林(bulid forest)</span>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(self.n_estimators):            tree = ClassificationTree(min_samples_split=self.min_samples_split, min_impurity=self.min_gain,                                      max_depth=self.max_depth)            self.trees.append(tree)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span><span class="hljs-params">(self, X, Y)</span>:</span>        <span class="hljs-comment"># 训练，每棵树使用随机的数据集(bootstrap)和随机的特征</span>        <span class="hljs-comment"># every tree use random data set(bootstrap) and random feature</span>        sub_sets = self.get_bootstrap_data(X, Y)        n_features = X.shape[<span class="hljs-number">1</span>]        <span class="hljs-keyword">if</span> self.max_features == <span class="hljs-literal">None</span>:            self.max_features = int(np.sqrt(n_features))        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.n_estimators):            <span class="hljs-comment"># 生成随机的特征</span>            <span class="hljs-comment"># get random feature</span>            sub_X, sub_Y = sub_sets[i]            idx = np.random.choice(n_features, self.max_features, replace=<span class="hljs-literal">True</span>)            sub_X = sub_X[:, idx]            self.trees[i].fit(sub_X, sub_Y)            self.trees[i].feature_indices = idx            print(<span class="hljs-string">"tree"</span>, i, <span class="hljs-string">"fit complete"</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span><span class="hljs-params">(self, X)</span>:</span>        y_preds = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.n_estimators):            idx = self.trees[i].feature_indices            sub_X = X[:, idx]            y_pre = self.trees[i].predict(sub_X)            y_preds.append(y_pre)        y_preds = np.array(y_preds).T        y_pred = []        <span class="hljs-keyword">for</span> y_p <span class="hljs-keyword">in</span> y_preds:            <span class="hljs-comment"># np.bincount()可以统计每个索引出现的次数</span>            <span class="hljs-comment"># np.argmax()可以返回数组中最大值的索引</span>            <span class="hljs-comment"># cheak np.bincount() and np.argmax() in numpy Docs</span>            y_pred.append(np.bincount(y_p.astype(<span class="hljs-string">'int'</span>)).argmax())        <span class="hljs-keyword">return</span> y_pred    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_bootstrap_data</span><span class="hljs-params">(self, X, Y)</span>:</span>        <span class="hljs-comment"># 通过bootstrap的方式获得n_estimators组数据</span>        <span class="hljs-comment"># get int(n_estimators) datas by bootstrap</span>        m = X.shape[<span class="hljs-number">0</span>]        Y = Y.reshape(m, <span class="hljs-number">1</span>)        <span class="hljs-comment"># 合并X和Y，方便bootstrap (conbine X and Y)</span>        X_Y = np.hstack((X, Y))        np.random.shuffle(X_Y)        data_sets = []        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(self.n_estimators):            idm = np.random.choice(m, m, replace=<span class="hljs-literal">True</span>)            bootstrap_X_Y = X_Y[idm, :]            bootstrap_X = bootstrap_X_Y[:, :<span class="hljs-number">-1</span>]            bootstrap_Y = bootstrap_X_Y[:, <span class="hljs-number">-1</span>:]            data_sets.append([bootstrap_X, bootstrap_Y])        <span class="hljs-keyword">return</span> data_sets</code></pre></li></ul><ul><li><p>大部分模型在sklearn早已封装好：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> division, print_function<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<span class="hljs-keyword">from</span> utils <span class="hljs-keyword">import</span> train_test_split, accuracy_score, Plot<span class="hljs-keyword">from</span> random_forest.random_forest_model <span class="hljs-keyword">import</span> RandomForest<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    data = datasets.load_digits()    X = data.data    y = data.target    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.4</span>, seed=<span class="hljs-number">2</span>)    print(<span class="hljs-string">"X_train.shape:"</span>, X_train.shape)    print(<span class="hljs-string">"Y_train.shape:"</span>, y_train.shape)    clf = RandomForest(n_estimators=<span class="hljs-number">100</span>)    clf.fit(X_train, y_train)    y_pred = clf.predict(X_test)    accuracy = accuracy_score(y_test, y_pred)    print(<span class="hljs-string">"Accuracy:"</span>, accuracy)    Plot().plot_in_2d(X_test, y_pred, title=<span class="hljs-string">"Random Forest"</span>, accuracy=accuracy, legend_labels=data.target_names)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre></li></ul><ul><li><p>参考：</p><p>1.通俗易懂图示剖析随机森林 <a href="https://blog.csdn.net/cg896406166/article/details/83796557" target="_blank" rel="noopener">https://blog.csdn.net/cg896406166/article/details/83796557</a></p></li></ul><p>  2.Gini重要性评估 <a href="https://blog.csdn.net/zjuPeco/article/details/77371645" target="_blank" rel="noopener">https://blog.csdn.net/zjuPeco/article/details/77371645</a></p><p>  3.票选带图示 <a href="https://www.sohu.com/a/234722514_787107" target="_blank" rel="noopener">https://www.sohu.com/a/234722514_787107</a></p><p>  票选 <a href="https://blog.csdn.net/zjuPeco/article/details/77371645" target="_blank" rel="noopener">https://blog.csdn.net/zjuPeco/article/details/77371645</a></p><p>  4.GINI阿里实战：用Python实现随机森林 <a href="https://baijiahao.baidu.com/s?id=1621066120041839448&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1621066120041839448&amp;wfr=spider&amp;for=pc</a></p><p>  5.IForest<a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.IsolationForest.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.IsolationForest.html</a></p><p>  RForest<a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html</a></p><p>  一文看懂RF <a href="https://easyai.tech/ai-definition/random-forest/" target="_blank" rel="noopener">https://easyai.tech/ai-definition/random-forest/</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MachineLearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节码插桩</title>
    <link href="/2020/04/19/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/"/>
    <url>/2020/04/19/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9/</url>
    
    <content type="html"><![CDATA[<p>Mark <a href="https://www.codercto.com/a/68115.html" target="_blank" rel="noopener">https://www.codercto.com/a/68115.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Blog新增安卓版客户端</title>
    <link href="/2020/04/05/Blog%E6%96%B0%E5%A2%9E%E5%AE%89%E5%8D%93%E7%89%88%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2020/04/05/Blog%E6%96%B0%E5%A2%9E%E5%AE%89%E5%8D%93%E7%89%88%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<ul><li>github速度较慢,优先选择第二个gitee地址下载<ul><li>(点击链接下载apk安装文件github)(<a href="https://github.com/foresight100/foresight100.github.io/releases/download/1.0/BlogByForesight.apk" target="_blank" rel="noopener">https://github.com/foresight100/foresight100.github.io/releases/download/1.0/BlogByForesight.apk</a>)</li><li>(点击链接下载apk安装文件gitee)(<a href="https://gitee.com/wangqiuchen/foresight100.github.io/attach_files/393275/download" target="_blank" rel="noopener">https://gitee.com/wangqiuchen/foresight100.github.io/attach_files/393275/download</a>)</li></ul></li></ul><p><img src="https://i.loli.net/2020/05/15/Pd7vQC3AhbqIuXV.jpg" srcset="/img/loading.gif" alt="Screenshot_com.wangqiuchen.Blog.jpg"><br><img src="https://i.loli.net/2020/05/15/wNnRxLH9GCaQrcf.jpg" srcset="/img/loading.gif" alt="Screenshot_com.wangqiuchen.Blog.jpg"><br><img src="https://i.loli.net/2020/05/15/vRu1sonOaFldicY.jpg" srcset="/img/loading.gif" alt="Screenshot_com.wangqiuchen.Blog.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>客户端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>isolationForest 孤立森林</title>
    <link href="/2020/03/28/isolationForest-%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97/"/>
    <url>/2020/03/28/isolationForest-%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<p>王秋辰的技术分享 in DianGroup    2020.3</p><a id="more"></a><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>介绍异常检测；</li><li>异常检测的用例；</li><li>孤立森林是什么；</li><li>用孤立森林进行异常检测；</li><li>用 Python 实现。</li></ul><h2 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h2><p>离群值是在给定数据集中，与其他数据点显著不同的数据点。</p><p>异常检测是找出数据中离群值（和大多数数据点显著不同的数据点）的过程。</p><p>真实世界中的大型数据集的模式可能非常复杂，很难通过查看数据就发现其模式。这就是为什么异常检测的研究是机器学习中极其重要的应用。</p><p>本文要用孤立森林实现异常检测。我们有一个简单的工资数据集，其中一些工资是异常的。目标是要找到这些异常值。可以想象成，公司中的一些雇员挣了一大笔不同寻常的巨额收入，这可能意味着存在不道德的行为。</p><h2 id="异常检测用例"><a href="#异常检测用例" class="headerlink" title="异常检测用例"></a>异常检测用例</h2><p><strong>银行：</strong>发现不正常的高额存款。每个账户持有人通常都有固定的存款模式。如果这个模式出现了异常值，那么银行就要检测并分析这种异常（比如洗钱）。</p><p><strong>金融：</strong>发现欺诈性购买的模式。每个人通常都有固定的购买模式。如果这种模式出现了异常值，银行需要检测出这种异常，从而分析其潜在的欺诈行为。</p><p><strong>卫生保健：</strong>检测欺诈性保险的索赔和付款。</p><p><strong>制造业：</strong>可以监测机器的异常行为，从而控制成本。许多公司持续监视着机器的输入和输出参数。众所周知，在出现故障之前，机器的输入或输出参数会有异常。从预防性维护的角度出发，需要对机器进行持续监控。</p><p><strong>网络：</strong>检测网络入侵。任何对外开放的网络都面临这样的威胁。监控网络中的异常活动，可以及早防止入侵。</p><h2 id="孤立森林"><a href="#孤立森林" class="headerlink" title="孤立森林"></a>孤立森林</h2><p>孤立森林是用于异常检测的机器学习算法。这是一种无监督学习算法，通过隔离数据中的离群值识别异常。</p><p><strong>孤立森林是基于决策树的算法</strong>。从给定的特征集合中随机选择特征，然后在特征的最大值和最小值间随机选择一个分割值，来隔离离群值。这种特征的随机划分会使异常数据点在树中生成的路径更短，从而将它们和其他数据分开。</p><p>一般而言，异常检测的第一步是构造「正常」内容，然后报告任何不能视为正常的异常内容。但孤立森林算法不同于这一原理，首先它不会定义「正常」行为，而且也没有计算基于点的距离。</p><p><strong>一如其名，孤立森林不通过显式地隔离异常，它隔离了数据集中的异常点</strong>。</p><p>孤立森林的原理是：异常值是少量且不同的观测值，因此更易于识别。孤立森林集成了孤立树，在给定的数据点中隔离异常值。</p><p>孤立森林通过随机选择特征，然后随机选择特征的分割值，递归地生成数据集的分区。和数据集中「正常」的点相比，要隔离的异常值所需的随机分区更少，因此异常值是树中路径更短的点，路径长度是从根节点经过的边数。</p><p><strong>用孤立森林，不仅可以更快地检测异常，还需要更少的内存</strong>。</p><p>孤立森林隔离数据点中的异常值，而不是分析正常的数据点。和其他正常的数据点相比，异常数据点的树路径更短，因此在孤立森林中的树不需要太大的深度，所以可以用更小的 max_depth 值，从而降低内存需求。</p><p>这一算法也适用于小数据集。</p><p>接着我们对数据做一些探索性分析，以了解给定数据的相关信息。</p><h2 id="探索性数据分析"><a href="#探索性数据分析" class="headerlink" title="探索性数据分析"></a><strong>探索性数据分析</strong></h2><p>先导入所需的库。导入 numpy、pandas、seaborn 和 matplotlib。此外还要从 sklearn.ensemble 中导入孤立森林（IsolationForest）。</p><pre><code class="hljs plain">import numpy as npimport pandas as pdimport seaborn as snsimport matplotlib.pyplot as pltfrom sklearn.ensemble import IsolationForest</code></pre><p>导入库后，要将 csv 数据读取为 padas 数据框，检查前十行数据。</p><p>本文所用数据是不同职业的人的年薪（美元）。数据中有一些异常值（比如工资太高或太低），目标是检测这些异常值。</p><pre><code class="hljs plain">df &#x3D; pd.read_csv(&#39;salary.csv&#39;)df.head(10)</code></pre><p>为了更好地了解数据，将工资数据绘制成小提琴图，如下图所示。小提琴图是一种绘制数值数据的方法。</p><p>通常，小提琴图包含箱图中所有数据——中位数的标记和四分位距的框或标记，如果样本数量不太大，图中可能还包括所有样本点。</p><p><em>工资的小提琴图。</em></p><p>为了更好地了解离群值，可能还会查看箱图。箱图一般也称为箱线图。箱图中的箱子显示了数据集的四分位数，线表示剩余的分布。线不表示确定为离群值的点。</p><p>我们通过 interquartile range, 的函数检测离群值。在统计数据中，interquartile range，（也称为 midspread 或 middle 50%）是度量统计学分散度的指标，等于第 75% 个数和第 25% 个数的差。</p><p><em>工资的箱图，指示了右侧的两个离群值。</em></p><p>完成数据的探索性分析后，就可以定义并拟合模型了。</p><p><strong>定义及拟合模型</strong></p><p>我们要创建一个模型变量，并实例化 IsolationForest（孤立森林）类。将这四个参数的值传递到孤立森林方法中，如下所示。</p><ul><li>评估器数量：n_estimators 表示集成的基评估器或树的数量，即孤立森林中树的数量。这是一个可调的整数参数，默认值是 100；</li><li>最大样本：max_samples 是训练每个基评估器的样本的数量。如果 max_samples 比样本量更大，那么会用所用样本训练所有树。max_samples 的默认值是『auto』。如果值为『auto』的话，那么 max_samples=min(256, n_samples)；</li><li>数据污染问题：算法对这个参数非常敏感，它指的是数据集中离群值的期望比例，根据样本得分拟合定义阈值时使用。默认值是『auto』。如果取『auto』值，则根据孤立森林的原始论文定义阈值；</li><li>最大特征：所有基评估器都不是用数据集中所有特征训练的。这是从所有特征中提出的、用于训练每个基评估器或树的特征数量。该参数的默认值是 1。</li></ul><pre><code class="hljs plain">model&#x3D;IsolationForest(n_estimators&#x3D;50, max_samples&#x3D;&#39;auto&#39;, contamination&#x3D;float(0.1),max_features&#x3D;1.0)model.fit(df[[&#39;salary&#39;]])</code></pre><p><em>孤立森林模型训练输出。</em></p><p>模型定义完后，就要用给定的数据训练模型了，这是用 fit() 方法实现的。这个方法要传入一个参数——使用的数据（在本例中，是数据集中的工资列）。</p><p>正确训练模型后，将会输出孤立森林实例（如图所示）。现在可以添加分数和数据集的异常列了。</p><p><strong>添加分数和异常列</strong></p><p>在定义和拟合完模型后，找到分数和异常列。对训练后的模型调用 decision_function()，并传入工资作为参数，找出分数列的值。</p><p>类似的，可以对训练后的模型调用 predict() 函数，并传入工资作为参数，找到异常列的值。</p><p>将这两列添加到数据框 df 中。添加完这两列后，查看数据框。如我们所料，数据框现在有三列：工资、分数和异常值。分数列中的负值和异常列中的 -1 表示出现异常。异常列中的 1 表示正常数据。</p><p>这个算法给训练集中的每个数据点都分配了异常分数。可以定义阈值，根据异常分数，如果分数高于预定义的阈值，就可以将这个数据点标记为异常。</p><pre><code class="hljs plain">df[&#39;scores&#39;]&#x3D;model.decision_function(df[[&#39;salary&#39;]])df[&#39;anomaly&#39;]&#x3D;model.predict(df[[&#39;salary&#39;]])df.head(20)</code></pre><p><em>给数据的每一行中都添加了分数和异常值后，就可以打印预测的异常了。</em></p><p><strong>打印异常</strong></p><p>为了打印数据中预测得到的异常，在添加分数列和异常列后要分析数据。如前文所述，预测的异常在预测列中的值为 -1，分数为负数。根据这一信息，将预测的异常（本例中是两个数据点）打印如下。</p><pre><code class="hljs plain">anomaly&#x3D;df.loc[df[&#39;anomaly&#39;]&#x3D;&#x3D;-1]anomaly_index&#x3D;list(anomaly.index)print(anomaly)</code></pre><p>注意，这样不仅能打印异常值，还能打印异常值在数据集中的索引，这对于进一步处理是很有用的。</p><h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a><strong>评估模型</strong></h2><p>为了评估模型，将阈值设置为工资&gt;99999 的为离群值。用以下代码找出数据中存在的离群值：</p><pre><code class="hljs plain">outliers_counter &#x3D; len(df[df[&#39;salary&#39;] &gt; 99999])outliers_counter</code></pre><p>计算模型找到的离群值数量除以数据中的离群值数量，得到模型的准确率。</p><pre><code class="hljs plain">print(&quot;Accuracy percentage:&quot;, 100*list(df[&#39;anomaly&#39;]).count(-1)&#x2F;(outliers_counter))</code></pre><p>准确率：100%</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>以jupyter notebook打开最佳</p><pre><code class="hljs python"><span class="hljs-comment">#%%</span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> IsolationForestdf = pd.read_csv(<span class="hljs-string">'salary.csv'</span>)df.head(len(df))<span class="hljs-string">'''定义及拟合模型我们要创建一个模型变量，并实例化 IsolationForest（孤立森林）类。将这四个参数的值传递到孤立森林方法中，如下所示。评估器数量：n_estimators 表示集成的基评估器或树的数量，即孤立森林中树的数量。这是一个可调的整数参数，默认值是 100；最大样本：max_samples 是训练每个基评估器的样本的数量。如果 max_samples 比样本量更大，那么会用所用样本训练所有树。max_samples 的默认值是『auto』。如果值为『auto』的话，那么 max_samples=min(256, n_samples)；数据污染问题：算法对这个参数非常敏感，它指的是数据集中离群值的期望比例，根据样本得分拟合定义阈值时使用。默认值是『auto』。如果取『auto』值，则根据孤立森林的原始论文定义阈值；最大特征：所有基评估器都不是用数据集中所有特征训练的。这是从所有特征中提出的、用于训练每个基评估器或树的特征数量。该参数的默认值是 1。'''</span>model=IsolationForest(n_estimators=<span class="hljs-number">100</span>,                      max_samples=<span class="hljs-string">'auto'</span>,                       contamination=<span class="hljs-string">'auto'</span>,<span class="hljs-comment"># </span>                      max_features=<span class="hljs-number">1.0</span>)model.fit(df[[<span class="hljs-string">'salary'</span>]])df[<span class="hljs-string">'scores'</span>]=model.decision_function(df[[<span class="hljs-string">'salary'</span>]])df[<span class="hljs-string">'anomaly'</span>]=model.predict(df[[<span class="hljs-string">'salary'</span>]])df.head(len(df))anomaly=df.loc[df[<span class="hljs-string">'anomaly'</span>]==<span class="hljs-number">-1</span>]anomaly_index=list(anomaly.index)print(anomaly)print(anomaly_index)outliers_counter = len(df[df[<span class="hljs-string">'salary'</span>] &gt; <span class="hljs-number">9999999</span>])outliers_counterprint(<span class="hljs-string">"Accuracy percentage:"</span>, <span class="hljs-number">100</span>*list(df[<span class="hljs-string">'anomaly'</span>]).count(<span class="hljs-number">-1</span>)/(outliers_counter))</code></pre><p>salary.csv</p><pre><code class="hljs markdown">salary261004234443254454446757673188766746456465464654649342334432449146234444444444444257592236860715185071155912355324554444444431233477544423455435643253432535345342424</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>machine learning</tag>
      
      <tag>机器学习</tag>
      
      <tag>isolationForest</tag>
      
      <tag>forest</tag>
      
      <tag>shear</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式—observer-Eventbus</title>
    <link href="/2020/03/15/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E2%80%94observer-Eventbus/"/>
    <url>/2020/03/15/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E2%80%94observer-Eventbus/</url>
    
    <content type="html"><![CDATA[<p>mark  <a href="https://eirunye.github.io/2018/09/01/观察者模式/" target="_blank" rel="noopener">https://eirunye.github.io/2018/09/01/观察者模式/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>决策树算法</title>
    <link href="/2020/03/02/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/02/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2><h4 id="1-简单概括"><a href="#1-简单概括" class="headerlink" title="1. 简单概括"></a>1. 简单概括</h4><blockquote><p>利用熵将整个数据集进行分割</p><p>使得分割后数据集的熵最小</p><p>不断对子数据集进行递归</p><p>直至无法进一步分割或者子数据集里数据的标签都一致时递归结束</p><p>分割的过程会形成一棵决策树</p><p>利用决策树将输入的数据归类到某一分割后的数据集中</p><p>子数据集所带有的标签就是决策的结果</p></blockquote><h4 id="2-熵的定义和实现"><a href="#2-熵的定义和实现" class="headerlink" title="2. 熵的定义和实现"></a>2. 熵的定义和实现</h4><blockquote><p>熵定义为信息的期望值</p></blockquote><ul><li><p><strong>信息的计算公式为</strong></p><script type="math/tex; mode=display">l(x_i) = -log_2p(x_i) \quad 其中 \ p(x_i) \ 是选择某一分类的概率</script></li><li><p><strong>信息的期望值为</strong></p><script type="math/tex; mode=display">H = -\sum_{i=1}^n p(x_i)log_2p(x_i)</script></li><li><p><strong>核心代码</strong></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcShannon</span><span class="hljs-params">(dataSet)</span>:</span>    dataSetSize = len(dataSet)    result = &#123;&#125;    <span class="hljs-comment"># 利用字典统计每一种标签的数据数量</span>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataSet:        label = data[<span class="hljs-number">-1</span>]        result[label] = result.get(label, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>    shannon = <span class="hljs-number">0</span>    <span class="hljs-comment"># 对于每一种分类计算其概率并统计信息熵</span>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> result:        prob = result[key]/dataSetSize        shannon -= prob * math.log(prob, <span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> shannon</code></pre></li></ul><h4 id="3-分割数据集"><a href="#3-分割数据集" class="headerlink" title="3. 分割数据集"></a>3. 分割数据集</h4><pre><code class="hljs python"><span class="hljs-comment"># 分割数据集，将维度axis且值为value的数据单独提取出来</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitDataSet</span><span class="hljs-params">(dataSet, axis, value)</span>:</span>    result = []    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataSet:        <span class="hljs-keyword">if</span> data[axis] == value:            <span class="hljs-comment"># 使用axis分割后将axis这一列从数据中去掉</span>            tmp = data[:axis]            <span class="hljs-comment"># 这里通过entend拼接数组跳过了axis这一列</span>            tmp.extend(data[axis+<span class="hljs-number">1</span>:])            result.append(tmp)    <span class="hljs-keyword">return</span> result</code></pre><h4 id="4-选择最好的分割维度"><a href="#4-选择最好的分割维度" class="headerlink" title="4. 选择最好的分割维度"></a>4. 选择最好的分割维度</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chooseBestSplitAxis</span><span class="hljs-params">(dataSet)</span>:</span>    numOfAxis = len(dataSet[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>    baseEntropy = calcShannon(dataSet)    bestInfoGain = <span class="hljs-number">0.0</span>    bestAxis = <span class="hljs-number">-1</span>    <span class="hljs-comment"># 对所有维度都循环试验</span>    <span class="hljs-keyword">for</span> axis <span class="hljs-keyword">in</span> range(numOfAxis):        allValue = [x[axis] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> dataSet]        <span class="hljs-comment"># 维度下所有可能的不重复值</span>        valueSet = set(allValue)        newEntropy = <span class="hljs-number">0.0</span>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> valueSet:            <span class="hljs-comment"># 按不重复的值分割成子数据集</span>            subDataSet = splitDataSet(dataSet, axis, value)            prob = float(len(subDataSet)) / float(len(dataSet))            <span class="hljs-comment"># 新的熵为部分熵按比例求和</span>            newEntropy += prob * calcShannon(subDataSet)        <span class="hljs-comment"># 作差为正说明新熵比旧熵小，混乱程度减小</span>        <span class="hljs-comment"># newInfoGain = baseEntropy - newEntropy</span>        <span class="hljs-comment"># if newInfoGain &gt; bestInfoGain:</span>            <span class="hljs-comment"># bestAxis = axis</span>            <span class="hljs-comment"># bestInfoGain = newInfoGain</span>        <span class="hljs-keyword">if</span> newEntropy &lt; baseEntropy:            <span class="hljs-comment"># 上面源码有点绕 简单理解就是熵变小了就选择</span>            bestAxis = axis    <span class="hljs-keyword">return</span> bestAxis</code></pre><h4 id="5-生成决策树"><a href="#5-生成决策树" class="headerlink" title="5. 生成决策树"></a>5. 生成决策树</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createTree</span><span class="hljs-params">(dataSet, labels)</span>:</span>    labelList = [data[<span class="hljs-number">-1</span>] <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataSet]    <span class="hljs-comment"># 递归出口一：子数据集的标签已经统一只有一种，不需要再进一步分割</span>    <span class="hljs-keyword">if</span> labelList.count(labelList[<span class="hljs-number">0</span>]) == len(labelList):        <span class="hljs-keyword">return</span> labelList[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 递归出口二：子数据集已经没有了可分割的维度只剩下了标签</span>    <span class="hljs-keyword">if</span> len(dataSet[<span class="hljs-number">0</span>]) == <span class="hljs-number">1</span>:        <span class="hljs-comment"># 统计子数据集中出现次数最多的标签即为决策结果</span>        <span class="hljs-keyword">return</span> voteMaxLabel(labelList)    <span class="hljs-comment"># 选择熵最小的分割维度</span>    bestAxis = chooseBestSplitAxis(dataSet)    bestLabel = labels[bestAxis]    <span class="hljs-comment"># 建立决策树字典</span>    myTree = &#123;bestLabel: &#123;&#125;&#125;    <span class="hljs-comment"># 删除已用于分割的维度对应的标签</span>    <span class="hljs-keyword">del</span>(labels[bestAxis])    allValue = [x[bestAxis] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> dataSet]    valueSet = set(allValue)    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> valueSet:        <span class="hljs-comment"># 复制一遍标签</span>        subLabel = labels[:]        <span class="hljs-comment"># 采用最好的分割方法分割数据集后递归生成子树</span>        myTree[bestLabel][value] = createTree(splitDataSet(dataSet, bestAxis, value), subLabel)    <span class="hljs-keyword">return</span> myTree</code></pre><h4 id="6-利用决策树进行决策"><a href="#6-利用决策树进行决策" class="headerlink" title="6. 利用决策树进行决策"></a>6. 利用决策树进行决策</h4><ul><li><p><strong>决策树生成范例</strong></p><blockquote><p>{‘flippers’: {0: ‘no’, 1: {‘no surfacing’: {0: ‘no’, 1: ‘yes’}}}}</p><p>其中每一次决策需要用到决策树的两层</p><p>以这里的决策树为例</p><p>第一层‘flippers’为进行决策的标签</p><p>第二层的0和1为在该标签下进行决策的不同选择</p></blockquote></li><li><p><strong>核心代码</strong></p></li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classifyByTree</span><span class="hljs-params">(tree, labels, data)</span>:</span>    <span class="hljs-comment"># 得到进行决策的标签</span>    firstLabel = list(tree.keys())[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 用该标签进行决策的子树</span>    secondDict = tree[firstLabel]    <span class="hljs-comment"># 得到用于决策的标签所属的维度，用于后面取出数据在该维度的值</span>    firstLabelIndex = labels.index(firstLabel)    classLabel = <span class="hljs-string">'Error'</span>    <span class="hljs-comment"># 对于该标签下进行决策的不同的值</span>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> secondDict.keys():        <span class="hljs-comment"># 如果数据在该决策标签维度下的值等于子树的决策值</span>        <span class="hljs-keyword">if</span> data[firstLabelIndex] == value:            <span class="hljs-comment"># 如果子树下还有子树（即还是一个字典类型的数据）则继续进行决策</span>            <span class="hljs-keyword">if</span> type(secondDict[value]).__name__ == <span class="hljs-string">'dict'</span>:                classLabel = classifyByTree(secondDict[value], labels, data)            <span class="hljs-keyword">else</span>:                <span class="hljs-comment"># 否则子树下的值就是决策的结果</span>                classLabel = secondDict[value]    <span class="hljs-keyword">return</span> classLabel</code></pre>]]></content>
    
    
    <categories>
      
      <category>MachineLearningInAction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Note for learning Android</title>
    <link href="/2020/02/21/Note-for-learning-Android/"/>
    <url>/2020/02/21/Note-for-learning-Android/</url>
    
    <content type="html"><![CDATA[<h2 id="First-写在前面"><a href="#First-写在前面" class="headerlink" title="First.写在前面"></a>First.写在前面</h2><ul><li>接触Android开发不觉已经半年有余，对Android开发的最直观印象便是Android各类组建的复杂，各种组建的使用好像学不完，用不完。从第一次打开Android Studio，到简单组合Github上的Demo，再到学习Java后自己上手写一些代码，总是觉得缺乏了对Android的通透的理解，还是得系统的深入了解。</li><li>高中接触过物竞，所思所学中，有一条最大的感悟便是：任何问题，都可以从微观中思考，从宏观深入到微观，必定能得以答案。</li><li>对代码能力的提高，我觉得也是从细致之处入手，多分析源码，多上手实操。</li><li>学习是有坡度的，这也是我从事开发的漫漫上坡路。<h2 id="Second-四大组件"><a href="#Second-四大组件" class="headerlink" title="Second.四大组件"></a>Second.四大组件</h2><h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><h2 id="Third-SomeNote"><a href="#Third-SomeNote" class="headerlink" title="Third.SomeNote"></a>Third.SomeNote</h2><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3></li><li>Context是维持Android程序中各组件能够正常工作的一个核心功能类。</li><li>弹出Toast、启动Activity、启动Service、发送广播、操作数据库等等都需要用到Context。</li><li><pre><code>  TextView tv = new TextView(getContext());  ListAdapter adapter = new SimpleCursorAdapter(getApplicationContext(), ...);  AudioManager am = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);getApplicationContext().getSharedPreferences(name, mode);  getApplicationContext().getContentResolver().query(uri, ...);  getContext().getResources().getDisplayMetrics().widthPixels * 5 / 8;  getContext().startActivity(intent);  getContext().startService(intent);  getContext().sendBroadcast(intent);</code></pre></li></ul><h3 id="Bundle-savedInstanceState"><a href="#Bundle-savedInstanceState" class="headerlink" title="Bundle savedInstanceState"></a>Bundle savedInstanceState</h3><ul><li><p>onCreate方法的完整定义如下:</p><pre><code>  public void onCreate(Bundle savedInstanceState){  super.onCreate(savedInstanceState);  }</code></pre></li><li>从上面的代码可以看出，onCreate方法的参数是一个Bundle类型的参数。Bundle类型的数据与Map类型的数据相似，都是以key-value的形式存储数据的。</li><li>从字面上看savedInstanceState，是保存实例状态的。实际上，savedInstanceState也就是保存Activity的状态的</li><li>eg. SnakeView in SnakeGame :</li><li><pre><code>  private int[] coordArrayListToArray(ArrayListcvec) {          int count = cvec.size();          int[] rawArray = new int[count * 2];          for (int index = 0; index &lt; count; index++) {              Coordinate c = cvec.get(index);              rawArray[2 * index] = c.x;              rawArray[2 * index + 1] = c.y;          }          return rawArray;      }      public Bundle saveState() {          Bundle map = new Bundle();          map.putIntArray(&quot;mAppleList&quot;, coordArrayListToArray(mAppleList));          map.putInt(&quot;mDirection&quot;, Integer.valueOf(mDirection));          map.putInt(&quot;mNextDirection&quot;, Integer.valueOf(mNextDirection));          map.putLong(&quot;mMoveDelay&quot;, Long.valueOf(mMoveDelay));          map.putLong(&quot;mScore&quot;, Long.valueOf(mScore));          map.putIntArray(&quot;mSnakeTrail&quot;, coordArrayListToArray(mSnakeTrail));          return map;      }  在snakeActivity中实现  @Override      public void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          setContentView(R.layout.snake_layout);          mSnakeView = (SnakeView) findViewById(R.id.snake);          mSnakeView.setTextView((TextView) findViewById(R.id.text));          if (savedInstanceState == null) {              // We were just launched -- set up a new game              mSnakeView.setMode(SnakeView.READY);          } else {              // We are being restored              Bundle map = savedInstanceState.getBundle(ICICLE_KEY);              if (map != null) {                  mSnakeView.restoreState(map);              } else {                  mSnakeView.setMode(SnakeView.PAUSE);              }          }      }  并重写onSavedInstanceState（），此方法会在activity结束时，调用.      @Override      public void onSaveInstanceState(Bundle outState) {          //Store the game state          outState.putBundle(ICICLE_KEY, mSnakeView.saveState());      }</code></pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>环境搭建、python基础语法笔记</title>
    <link href="/2020/02/02/pandas%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88prepare-for-machineLearning%EF%BC%89/"/>
    <url>/2020/02/02/pandas%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88prepare-for-machineLearning%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><ul><li>安装tensorFlow和jupyter断断续续折腾了尽一个月，一开始一直报错原来是因为虚拟环境初始化为了python2.7（并不是最初认为的tensorFlow无3.7版本），tensorflow2.0对于python3.7已经支持。原来最好的安装方法是：python3.7虚拟环境+国内镜像tensorFlow+pip安装jupyter_notebook。</li><li>anaconda-Navigator的GUI界面安装也是一个不错的选择，对于import python包确实方便；缺点就是不知如何改为国内源，速度不快。<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3></li><li><ul><li>1）def创建的方法是有名称的，而lambda没有。</li><li>2）lambda会返回一个函数对象，但这个对象不会赋给一个标识符，而def则会把函数对象赋值给一个变量（函数名）。</li><li>3）lambda只是一个表达式，而def则是一个语句。</li><li>4）lambda表达式” : “后面，只能有一个表达式，def则可以有多个。</li><li>5）像if或for或print等语句不能用于lambda中，def可以。</li><li>6）lambda一般用来定义简单的函数，而def可以定义复杂的函数。</li><li><p>7）lambda函数不能共享给别的程序调用，def可以。</p><pre><code>lambda [arg1 [, agr2,.....argn]] : expression1、单个参数的：&gt;&gt;&gt; g = lambda x : x ** 2&gt;&gt;&gt; print g(3)92、多个参数的：&gt;&gt;&gt; g = lambda x, y, z : (x + y) ** z&gt;&gt;&gt; print g(1,2,2)9</code></pre></li><li>lambda表达式会返回一个函数对象，如果没有变量接受这个返回值的话，它很快就会被丢弃。也正是由于lambda只是一个表达式，所以它可以直接作为list和dict的成员。<pre><code>&gt;&gt;&gt; list_a = [lambda a: a**3, lambda b: b**3]&gt;&gt;&gt; list_a[0]&lt;function &lt;lambda&gt; at 0x0259B8B0&gt;&gt;&gt;&gt; g = list_a[0]&gt;&gt;&gt; g(2)8</code></pre></li><li><p>上块存疑</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map(fun, iter)</p><h1 id="Return-double-of-n"><a href="#Return-double-of-n" class="headerlink" title="Return double of n"></a>Return double of n</h1><p>def addition(n):<br>return n + n </p><h1 id="We-double-all-numbers-using-map"><a href="#We-double-all-numbers-using-map" class="headerlink" title="We double all numbers using map()"></a>We double all numbers using map()</h1><p>numbers = (1, 2, 3, 4)<br>result = map(addition, numbers)<br>print(list(result)) </p><p>output:<br>{2, 4, 6, 8}</p></li></ul></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine learning</tag>
      
      <tag>机器学习</tag>
      
      <tag>pandas</tag>
      
      <tag>tensorFlow</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>团队年鉴-我的2019</title>
    <link href="/2019/12/31/%E5%9B%A2%E9%98%9F%E5%B9%B4%E9%89%B4-%E6%88%91%E7%9A%842019/"/>
    <url>/2019/12/31/%E5%9B%A2%E9%98%9F%E5%B9%B4%E9%89%B4-%E6%88%91%E7%9A%842019/</url>
    
    <content type="html"><![CDATA[<ul><li>想来，作为一名新队员，团队年鉴对我而言自是意义非凡。2019年对我个人而言算是一个人生中的转折点，标志着以往18年未成年的结束，也是此后数十年的开始，是我踏出故乡的第一步。</li><li>光阴似箭，日月如梭，不知不觉一个学期就过去了，仿佛昨天才踏入华中大、来到Dian团队，在团队的三个月，我深刻体会了知识海洋的浩瀚无边，也对人的无限潜能有深刻的感悟。</li><li>“人生没有白走的路，每一步都算数。”是在今年的6月23日，当我拿到高考成绩单时，我便明白，我与华中大的缘分就此开始，我也在缓缓向Dian团队靠齐。</li><li>刚从高中升入大学的我曾把高三当作人生最苦的时期，确实，高中确实辛苦，早出晚归，做不完的作业，刷不完的习题，终日与疲劳和杂念做斗争，单调乏味和无聊痛苦交织着，怎能不苦呢？现在我才明白，原来大学绝非轻松之地，对比高中犹有过之，若高中是在永无止境的走路，那么大学便需要拼命地奔跑，但我是幸福的奔跑着的。</li><li>我一直信奉一个道理，人的所有的成就都是自身素质的体现，成绩、成就绝非智商所决定，而仅仅是个人优秀品质的必然结果。能在团队之中，我深感我的幸运。这里不是冷冰冰的技术，而是充满着人情味，这里的每月一善等暖心活动更让我见识到了一个团体的优秀素质。我学到的不仅是技术，更是坚持、善良，是对目标的坚定和永不放弃的决心。</li><li>初入大学，我学习了python，啃完了《python从入门到实践》、《以计算机学家一样思考python》，一行行简单的代码通过组合、嵌套竟能实现如此繁复的功能，对代码的热爱便由此激发，不曾想，这一段简单的经历也帮助我挺过了熬测大关。不得不又应证了开头的那段话，人生怎会有白走的路呢？</li><li>加入团队后，我选择了自己尚未接触过的语言—Java。人的潜能是无限的，千万不能停留在舒适区，那我何不选择自己毫无经验的Android作为自己的学习目标呢？怀着激动的心情，我加入了启亦电子组。</li><li>一个人走的快，但一群人才能走得远。初入项目组，我就感觉在这有大量的知识待我学习。</li><li>新人任务帮助我迅速熟悉Android。做任务的同时，配合着《第一行代码》，虽毫无Java基础，但是确实对项目结构有了初步掌握，我领到的第一份任务是制作一个简单的记事本程序。“麻雀虽小，五脏俱全”；app虽小，内容却多。从简单的选择模版，运用RecyclerView，再到构建闹铃，理解service和broadcast，同时还有数据库的增删查改，每一点知识的学会都是艰难的一步，需要付出时间和专注。</li><li>组会分享干货多多。不得不说，每周的组会真是收获颇多，编译原理、数据库运用、数据结构讲解等等，课内课外的知识有机结合，对于我而言不仅是眼界的开拓，更是对日后的学习打下的坚实的基础，帮助了我的成长，也提高了学习效率。</li><li>在队委会中，我在所在的公关组承担一部分拍照和协助接待工作，在与来宾打交道的过程中，我的沟通能力也得到了提升，让我能在未来承担更多的工作，更好地服务于团队。<br>“悟以往之不谏，知来者之可追。”总结是为了更好的提升，新一年的我已经准备好了迎接新的挑战!</li></ul>]]></content>
    
    
    <categories>
      
      <category>2019</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2019</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学生通讯录管理系统（一次c语言的初步探索运用）</title>
    <link href="/2019/12/22/%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%E6%AC%A1c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%E8%BF%90%E7%94%A8%EF%BC%89/"/>
    <url>/2019/12/22/%E5%AD%A6%E7%94%9F%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%E6%AC%A1c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%E8%BF%90%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>纪念人生第一次手撸2000行代码 (o^^o)♪<br><a id="more"></a><br><img src="https://i.loli.net/2019/12/22/AYRUeJpuT3DLiZP.jpg" srcset="/img/loading.gif" alt></p><h1 id="学生通讯录管理系统"><a href="#学生通讯录管理系统" class="headerlink" title="学生通讯录管理系统"></a>学生通讯录管理系统</h1><ul><li><strong>c语言课程设计</strong>  <h2 id="HUST-EIC"><a href="#HUST-EIC" class="headerlink" title="HUST EIC"></a>HUST EIC</h2></li></ul><h2 id="功能概述："><a href="#功能概述：" class="headerlink" title="功能概述："></a>功能概述：</h2><p>这是基于c语言的学生通讯录管理系统，包括以下功能：</p><ul><li><strong>导入csv等二进制格式文件</strong><ul><li>检测是否重复导入：若重复导入，提醒用户是否覆盖，或者回到主界面进行添加功能</li><li>检测文件是否存在：若存在则导入，若不存在会提示“NOT FOUND”重新导入</li></ul></li><li><strong>浏览所有学生信息</strong><ul><li>一键打印所有同学的所有信息</li></ul></li><li><strong>统计与查找所有学生信息</strong><ul><li>支持按各类特征查找，如：只查找名字或只查找学院，所有查找都支持模糊查找，如只输入姓氏，或只输入学院名称的几个字</li><li>支持关键字查找：输入关键字查找所有特征（即，把名字，学院，email等与关键字一一对比）</li><li>所有查找结果都返回查找的结果的个数</li><li>所有查找都支持模糊查找</li></ul></li><li><strong>排序</strong><ul><li>排序采用设标签法</li><li>设标签后，交换采用数据域的交换，而非结点的交换，有改进空间</li></ul></li><li><strong>删除学生信息</strong><ul><li>删除学生信息就是将该结点的上一级指针指向下一级，再free该结点</li><li>有避免误删的功能，即多次确定，且打印信息</li></ul></li><li><strong>添加新的学生信息</strong><ul><li>设计了两种添加学生信息的方式：<ul><li>用户手动添加</li><li>通过读取文件添加</li></ul></li><li>两种添加方式都直接添加在末尾</li></ul></li><li><strong>修改学生信息</strong><ul><li>根据学号的唯一性，通过学号找到学生本人然后进行修改。</li><li>同样具有容错性，例如：若查找不到学生，则打印 NOTFOUND！！</li></ul></li><li><strong>导出表格</strong><ul><li>输入导出表格的路径，若存在同名同路径文件，则覆盖，若不存在，则创建   </li></ul></li><li><strong>通知</strong><ul><li>base64加密和soket部分代码为网上demo，有些库函数不知osx和windows能否兼容<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><pre><code class="hljs mermaid">graph LRA[主界面] --&gt; B[导入文件]A[主界面] --&gt; C[排序]A[主界面] --&gt; D[浏览所有]A[主界面] --&gt; E[统计和查找]A[主界面] --&gt; F[添加新的学生信息]A[主界面] --&gt; G[修改学生信息]A[主界面] --&gt; H[删除学生信息]A[主界面] --&gt; I[导出]A[主界面] --&gt; J[通知学生]A[主界面] --&gt; K(退出程序)B--&gt;输入文件路径C--&gt;按姓名字典顺序排序C--&gt;按学号排序D--&gt;列表浏览所有学生信息E--&gt;5(统计与查找)5--&gt;按学号查找5--&gt;按名字查找5--&gt;按学院查找5--&gt;按地址查找5--&gt;按电话查找5--&gt;按邮箱查找F--&gt;手动添加F--&gt;文件添加G--&gt;查找--&gt;选择修改特征--&gt;键入修改后值--&gt;修改成功H--&gt;查找删除学生信息--&gt;1&#123;确定删除&#125;--&gt;删除I--&gt;选择输出路径--&gt;导出成功J--&gt;输入学生邮箱--&gt;send</code></pre><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2></li></ul></li><li><strong>结构采用一个功能一个模块（子函数），实现模块间的相互独立</strong></li><li><strong>存储数据的链表的表头是全局链表，可以不用传递参数便随时调取</strong></li><li><strong>进入功能后可以随时退出，回到主界面</strong></li><li><strong>所有模块都具有容错性</strong></li><li><strong>代码除「通知」模块的一部分，其他为纯手写</strong><h2 id="不足和改进空间"><a href="#不足和改进空间" class="headerlink" title="不足和改进空间"></a>不足和改进空间</h2></li><li>在统计和查找模块，可以利用定义函数来减少代码行数，但时间不足，暂来不及改变</li><li>结构还不够简洁</li><li>对学生信息的修改功能上，没有批量修改</li><li>对学生的信息统计能统计数目，暂不能有更多的统计功能</li><li>所有数据仅支持英文，中文在terminal中测试为乱码</li><li>发送通知的功能还需继续学习更多有关通信和加密的知识<h2 id="总结收获"><a href="#总结收获" class="headerlink" title="总结收获"></a>总结收获</h2></li><li>学会了链表的增删查改</li><li>学会了用c语言读写文件</li><li>对数组、指针、结构体的运用能力更近了一层</li><li>debug能力更强</li><li>初步接触套接字</li></ul><pre><code>  //  //  main.cpp  //  addresslist  //  //  Created by 王秋辰 on 2019/12/17.  //  Copyright © 2019 王秋辰. All rights reserved.  //电信1901班   王秋辰  /*************************************************************************************  caution!!!!!!!  atoi转换char为int  表格的形式必须为类似一下例子的可读文件，csv或者txt皆可  列分隔用“，”。行分隔用&#39;\n&#39;  name,num,sex,college,major,add,tel,QQ,email  mike,U201912345,1,EIC,eletricial information,yunyuan 23 107,13972108706,1194798160,1194798160@qq.com  john,U201912346,0,CS,computer science,yunyuan 22 106,13972108707,1194798161,1194798160@qq.com  eric,U201912347,1,EIC,eletricial information,yunyuan 23 106,13972108708,1194798162,1194798160@qq.com  通知功能需要配置邮箱的   POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 才能使用 &lt;&lt;--(不太懂)  *************************************************************************************/  //email模块所需  #include &lt;sys/types.h&gt;  #include &lt;sys/socket.h&gt;  #include &lt;netinet/in.h&gt;  #include &lt;errno.h&gt;  #include &lt;unistd.h&gt;  #include &lt;sys/time.h&gt;  #include &lt;cstring&gt;  #include &lt;arpa/inet.h&gt;  //  #include &lt;iostream&gt;  #include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #define NAMESIZE 99  #define MAJORSIZE 99  #define ADDSIZE 99  #define EMAILSIZE 99  #define COLLEGESIZE 99  #define NUMSIZE 99  #define TELSIZE 99  #define QQSIZE 99  #define SIZE 99//存储的最大容量  #define FILEPATHSIZE 99  #define CHANGESIZE 40  using namespace std;  typedef struct student{      char name[NAMESIZE];//姓名      char num[NUMSIZE];//学号      int sex;//man:1  woman:0      char college[COLLEGESIZE];//学院      char major[MAJORSIZE];//专业      char add[ADDSIZE];//地址      char tel[TELSIZE];//电话      char QQ[QQSIZE];//qq      char email[EMAILSIZE];//电子邮箱  } datatype;  typedef struct linknode{      datatype studentdata;      linknode *next;  } Node,*linklist;//定义节点  linknode *head=(Node*)malloc(sizeof(Node));//表头  //**************************************************************  //*************                                  ***************  //*************    打印所有学生信息模块声明           ***************  //*************                                  ***************  //**************************************************************  void printlink();//打印所有学生信息的界面  void output();//展示所有信息  int menu(void);//主菜单  //**************************************************************  //*************                                  ***************  //*************          导入模块声明             ***************  //*************                                  ***************  //**************************************************************  void create(char filepath[FILEPATHSIZE]);//=根据文件路径导入；创建链表  void input();//导入信息界面  //**************************************************************  //*************                                  ***************  //*************           查找模块声明             ***************  //*************                                  ***************  //**************************************************************  void Find();//查找界面  int checksubstr(char *str,char *sub_str);//检查字符串中是否包含子字符串  void printsingle(Node *p);//打印单个节点学生数据  int Findnum();//查找学号界面；输入学号  void searchnum(char *search);//按学号查找  int Findname();//按姓名查找界面;输入关键字  void searchname(char *search);//按姓名查找  int Findtel();//按电话查找界面;输入关键字  void searchtel(char *search);//按电话查找  int FindQQ();//按QQ查找界面;输入关键字  void searchQQ(char *search);//按QQ查找  int Findall();//关键字查找  void searchall(char *search);  int Findsex();//性别查找  void searchsex(int search);  int Findmajor();//专业查找  void searchmajor(char *search);  int Findaddress();//地址查找  void searchaddress(char *search);  int Findcollege();//学院查找  void searchcollege(char *search);  //**************************************************************  //*************                                  ***************  //*************           修改数据模块声明             ***************  //*************                                  ***************  //**************************************************************  void changedata();//界面  linklist searchnumchange(char *search);//找到待修改的值，并返回节点指针  //**************************************************************  //*************                                  ***************  //*************           删除数据模块声明          ***************  //*************                                  ***************  //**************************************************************  void deletedata();//界面  linklist findthefront();//找到待c删除节点的前一个节点，返回指针  //**************************************************************  //*************                                  ***************  //*************           添加数据模块             ***************  //*************                                  ***************  //**************************************************************  void adddata();//界面  void writebyhand();//手动写入  void writebyfile();//文件写入  //**************************************************************  //*************                                  ***************  //*************           导出数据模块             ***************  //*************                                  ***************  //**************************************************************  void exportdata();//界面和导出  //**************************************************************  //*************                                  ***************  //*************           排序模块声明             ***************  //*************                                  ***************  //**************************************************************  void sortdata();//界面  void sortbynum();//按学号排序  void exchange(linknode *p,linknode *q);//交换两个指针内的data  void sortbyname();//按name排序  //**************************************************************  //*************                                  ***************  //*************           发送邮件             ***************  //*************                                  ***************  //**************************************************************  void send();  struct data6  {      unsigned int d4:6;      unsigned int d3:6;      unsigned int d2:6;      unsigned int d1:6;  };  // 协议中加密部分使用的是base64方法  char con628(char c6);  void base64(char *dbuf,char *buf128,int len);  void sendemail(char *email,char *body);  int open_socket(struct sockaddr *addr);  void sendto(char *email);  //**************************************************************  //*************                                  ***************  //*************           主函数。                ***************  //*************                                  ***************  //**************************************************************  int main() {      system(&quot;clear&quot;);//osx环境      menu();      return 0;  }  //**************************************************************  //*************                                  ***************  //*************           主菜单。                ***************  //*************                                  ***************  //**************************************************************  int menu(void){      cout&lt;&lt;&quot;|------------------------------&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|-&gt;这里是学生通讯录管理系统&lt;-|&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[1]-导入&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[2]-按条件排序&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[3]-浏览所有学生信息&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[4]-统计与查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[5]-添加新的学生信息&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[6]-修改学生信息&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[7]-删除学生信息&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[8]-导出&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[9]-通知学生&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|----[0]-退出程序&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|------------------------------&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;请输入要进行的操作-&gt;&quot;&lt;&lt;endl;      int n=-1;      scanf(&quot;%d&quot;,&amp;n);      if (n&lt;=9&amp;&amp;n&gt;=1) {          switch (n) {              case 1:                  system(&quot;clear&quot;);                  input();                  break;              case 2:                  system(&quot;clear&quot;);                  sortdata();                  break;              case 3:                  system(&quot;clear&quot;);                  output();                  break;              case 4:                  system(&quot;clear&quot;);                  Find();                  break;              case 5:                  system(&quot;clear&quot;);                  adddata();                  break;              case 6:                  system(&quot;clear&quot;);                  changedata();                  break;              case 7:                  system(&quot;clear&quot;);                  deletedata();                  break;              case 8:                  system(&quot;clear&quot;);                  exportdata();                  break;              case 9:                  system(&quot;clear&quot;);                  send();                  break;              case 0:                  exit(1);              default:                  break;          }}      else{          fflush(stdin);          system(&quot;clear&quot;);//osx环境          printf(&quot;请键入正确的操作！！！\n&quot;);          menu();      }      return 0;  }  //**************************************************************  //*************                                  ***************  //*************           通知模块             ***************  //*************                                  ***************  //**************************************************************  //**************************************************************  //*************                                  ***************  //*************           排序模块             ***************  //*************                                  ***************  //**************************************************************  void sortdata(){      cout&lt;&lt;&quot;|--------[1]-按姓名排序&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|--------[2]-按学号排序&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|--------[0]-返回主菜单&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|--------请输入你的选项：&quot;&lt;&lt;endl;      int n = -1;      scanf(&quot;%d&quot;,&amp;n);      fflush(stdin);      switch (n) {          case 1:              sortbyname();              system(&quot;clear&quot;);              cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      姓氏排序成功！    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;              menu();              break;              break;          case 2:              sortbynum();              system(&quot;clear&quot;);              cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      学号排序成功！    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;              menu();              break;          case 0:              system(&quot;clear&quot;);              printf(&quot;&gt;&gt;&gt;&gt;请输入正确的选项!!!!!&lt;&lt;&lt;&lt;&quot;);              sortdata();              exit(1);              break;          default:              break;      }  }  //**************************************************************  //*************                                  ***************  //*************           按学号排序             ***************  //*************                                  ***************  //**************************************************************  void sortbynum(){      linknode *p,*q;      p=head;      while (p) {          q=p-&gt;next;          linknode *themin=p;          while (q) {              if (strcmp(p-&gt;studentdata.num, q-&gt;studentdata.num)&gt;0) {                  themin=q;              }              q=q-&gt;next;          }          exchange(p, themin);          p=p-&gt;next;      }  }  void exchange(linknode *p,linknode *q)  {      linknode *temp=(linknode*)malloc(sizeof(Node));      temp-&gt;studentdata = p-&gt;studentdata;      p-&gt;studentdata = q-&gt;studentdata;      q-&gt;studentdata = temp -&gt; studentdata;      free(temp);  }  //**************************************************************  //*************                                  ***************  //*************           按姓名排序             ***************  //*************                                  ***************  //**************************************************************  void sortbyname(){      linknode *p,*q;      p=head;      while (p) {          q=p-&gt;next;          linknode *themin=p;          while (q) {              if (strcmp(p-&gt;studentdata.name, q-&gt;studentdata.name)&gt;0) {                  themin=q;              }              q=q-&gt;next;          }          exchange(p, themin);          p=p-&gt;next;      }  }  //**************************************************************  //*************                                  ***************  //*************           导出数据模块             ***************  //*************                                  ***************  //**************************************************************  void exportdata(){      fflush(stdin);      cout&lt;&lt;&quot;|-------------------------------&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;返回上一级则按回车键&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;请输入导出文件路径(若文件存在，则会被覆盖)：&quot;&lt;&lt;endl;      char filepath[FILEPATHSIZE];      gets(filepath);      if (filepath[0]==&#39;\0&#39;) {          system(&quot;clear&quot;);          menu();      }      FILE *fp=fopen(filepath, &quot;w&quot;);      Node *read=head-&gt;next;      fputs(&quot;name,num,sex,college,major,add,tel,QQ,email\n&quot;, fp);      while (read) {          char tempsex[2];          if (read-&gt;studentdata.sex==1) {              strcpy(tempsex, &quot;1&quot;);          }          if (read-&gt;studentdata.sex==0) {              strcpy(tempsex, &quot;0&quot;);          }          fputs(read-&gt;studentdata.name, fp);          fputs(&quot;,&quot;, fp);          fputs(read-&gt;studentdata.num, fp);          fputs(&quot;,&quot;, fp);          fputs(tempsex, fp);          fputs(&quot;,&quot;, fp);          fputs(read-&gt;studentdata.college, fp);          fputs(&quot;,&quot;, fp);          fputs(read-&gt;studentdata.major, fp);          fputs(&quot;,&quot;, fp);          fputs(read-&gt;studentdata.add, fp);          fputs(&quot;,&quot;, fp);          fputs(read-&gt;studentdata.tel, fp);          fputs(&quot;,&quot;, fp);          fputs(read-&gt;studentdata.QQ, fp);          fputs(&quot;,&quot;, fp);          fputs(read-&gt;studentdata.email, fp);          read=read-&gt;next;      }      fclose(fp);      system(&quot;clear&quot;);      cout&lt;&lt;&quot;导出文件成功!&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;文件在&quot;&lt;&lt;filepath&lt;&lt;&quot;中&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;按任意键回到主菜单&quot;&lt;&lt;endl;      getchar();      system(&quot;clear&quot;);      fflush(stdin);      menu();      exit(1);  }  //**************************************************************  //*************                                  ***************  //*************           添加数据模块             ***************  //*************                                  ***************  //**************************************************************  void adddata()  {      fflush(stdin);      cout&lt;&lt;&quot;|---------[1]-从当前界面手动写入&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|---------[2]-从文件导入，从数据最后一行添加&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;|---------[3]-回到主界面&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;请输入你的选项:&quot;&lt;&lt;endl;      int n = 0;      fflush(stdin);      scanf(&quot;%d&quot;,&amp;n);      fflush(stdin);      switch (n) {          case 1:              writebyhand();              break;          case 2:              writebyfile();              break;          case 3:              fflush(stdin);              system(&quot;clear&quot;);              menu();              exit(1);          default:              fflush(stdin);              system(&quot;clear&quot;);              adddata();              break;      }      exit(1);  }  void writebyhand(){      fflush(stdin);      char *temname=(char*)malloc(NAMESIZE);      char *temnum=(char*)malloc(NUMSIZE);      int temsex=2;      char *temcollege=(char*)malloc(COLLEGESIZE);      char *temmajor=(char*)malloc(MAJORSIZE);      char *temadd=(char*)malloc(ADDSIZE);      char *temtel=(char*)malloc(TELSIZE);      char *temQQ=(char*)malloc(QQSIZE);      char *tememail=(char*)malloc(EMAILSIZE);      cout&lt;&lt;&quot;请输入姓名&quot;&lt;&lt;endl;      gets(temname);      cout&lt;&lt;&quot;请输入学号&quot;&lt;&lt;endl;      gets(temnum);      while (!(temsex==1||temsex==0)) {          cout&lt;&lt;&quot;请输入性别(男生为1，女生为0)&quot;&lt;&lt;endl;          scanf(&quot;%d&quot;,&amp;temsex);          if (!(temsex==1||temsex==0)) {              temsex=2;              cout&lt;&lt;&quot;请输入正确的数据!!!&quot;&lt;&lt;endl;          }          fflush(stdin);      }      fflush(stdin);      cout&lt;&lt;&quot;请输入学院&quot;&lt;&lt;endl;      gets(temcollege);      cout&lt;&lt;&quot;请输入专业&quot;&lt;&lt;endl;      gets(temmajor);      cout&lt;&lt;&quot;请输入地址&quot;&lt;&lt;endl;      gets(temadd);      cout&lt;&lt;&quot;请输入电话&quot;&lt;&lt;endl;      gets(temtel);      cout&lt;&lt;&quot;请输入QQ&quot;&lt;&lt;endl;      gets(temQQ);      cout&lt;&lt;&quot;请输入email&quot;&lt;&lt;endl;      fgets(tememail, EMAILSIZE, stdin);      linknode *theend=head;      while (theend-&gt;next) {          theend=theend-&gt;next;      }      linknode *tem;      tem=(Node*)malloc(sizeof(Node));      strcpy(tem-&gt;studentdata.name,temname);      strcpy(tem-&gt;studentdata.num,temnum);      tem-&gt;studentdata.sex=temsex;      strcpy(tem-&gt;studentdata.college,temcollege);      strcpy(tem-&gt;studentdata.major,temmajor);      strcpy(tem-&gt;studentdata.add,temadd);      strcpy(tem-&gt;studentdata.tel,temtel);      strcpy(tem-&gt;studentdata.QQ,temQQ);      strcpy(tem-&gt;studentdata.email,tememail);      tem-&gt;next=NULL;      theend-&gt;next=tem;</code></pre><p>​<br>​<br>​          free(temadd);<br>​          free(tememail);<br>​          free(temtel);<br>​          free(temQQ);<br>​          free(temmajor);<br>​          free(temcollege);<br>​          free(temnum);<br>​          free(temname);<br>​          fflush(stdin);<br>​          system(“clear”);<br>​          cout&lt;&lt;”—————————————————————-“&lt;&lt;endl;<br>​          cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>​          cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      手动导入成功！       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>​          cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>​          cout&lt;&lt;”—————————————————————-“&lt;&lt;endl;<br>​          menu();<br>​          exit(1);<br>​<br>      }</p><pre><code>  void writebyfile()  {      cout&lt;&lt;&quot;|-------------------------------&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;返回上一级则按回车键&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;请输入导入文件路径：&quot;&lt;&lt;endl;      char filepath[FILEPATHSIZE];      gets(filepath);      if (filepath[0]==&#39;\0&#39;) {          system(&quot;clear&quot;);          menu();      }      FILE *fp;      while ((fp=fopen(filepath, &quot;r&quot;))==NULL) {          printf(&quot;NOT FOUND！！请再次输入:\n&quot;);          gets(filepath);          if (filepath[0]==&#39;\0&#39;)          {              system(&quot;clear&quot;);              menu();              break;          }      }      linknode *theend=head;      while (theend-&gt;next) {          theend=theend-&gt;next;      }      fp=fopen(filepath, &quot;r&quot;);      linknode *p,*q;      p=q=theend;      char buffer[1024];      char *line,*record;//c保存行数据,单个列元素      line=fgets(buffer, sizeof(buffer), fp);//丢掉第一行      while ((line=fgets(buffer, sizeof(buffer), fp))!=NULL) {          q=(Node*)malloc(sizeof(Node));          record = strtok(line, &quot;,&quot;);          strcpy(q-&gt;studentdata.name,record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.num,record);          record = strtok(NULL, &quot;,&quot;);          q-&gt;studentdata.sex=atoi(record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.college,record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.major, record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.add, record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.tel,record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.QQ,record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.email, record);</code></pre><p>​<br>​              p-&gt;next=q;<br>​              p=q;<br>​          }<br>​          p-&gt;studentdata.email[strlen(q-&gt;studentdata.email)+1]=’\0’;<br>​          p-&gt;studentdata.email[strlen(q-&gt;studentdata.email)]=’\n’;<br>​          p-&gt;next=NULL;<br>​          fclose(fp);<br>​          fflush(stdin);<br>​          system(“clear”);<br>​          cout&lt;&lt;”—————————————————————-“&lt;&lt;endl;<br>​          cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>​          cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      文件导入成功！    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>​          cout&lt;&lt;”&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;”&lt;&lt;endl;<br>​          cout&lt;&lt;”—————————————————————-“&lt;&lt;endl;<br>​          menu();<br>​          exit(1);<br>​      }</p><pre><code>  //**************************************************************  //*************                                  ***************  //*************           删除数据模块             ***************  //*************                                  ***************  //**************************************************************  void deletedata(){      fflush(stdin);      cout&lt;&lt;&quot;请输入要删除的学生学号「完整学号」：&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;输入q回到主界面&quot;&lt;&lt;endl;      char *studentnum=(char*)malloc(NUMSIZE);      gets(studentnum);      if (strcmp(studentnum, &quot;q&quot;)==0) {          system(&quot;clear&quot;);          menu();          exit(1);      }      linklist target=searchnumchange(studentnum);      if(target){          system(&quot;clear&quot;);          printsingle(target-&gt;next);          printf(&quot;确定删除吗？（y/n）&quot;);          fflush(stdin);          char *check=(char*)malloc(sizeof(3));          gets(check);          if (strcmp(check, &quot;y&quot;)==0||strcmp(check, &quot;Y&quot;)==0) {              linklist p=target-&gt;next;              target-&gt;next=p-&gt;next;              free(p);              free(target);              free(check);              system(&quot;clear&quot;);              cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl;              deletedata();          }          else{              free(target);              free(check);              system(&quot;clear&quot;);              fflush(stdin);              deletedata();          }      }      else      {          fflush(stdin);          free(target);          free(studentnum);          system(&quot;clear&quot;);          printf(&quot;NOT FOUND&quot;);          deletedata();          exit(1);      }  }  //**************************************************************  //*************                                  ***************  //*************           修改数据模块             ***************  //*************                                  ***************  //**************************************************************  void changedata(){      fflush(stdin);      cout&lt;&lt;&quot;请输入要修改的学生学号「完整学号」：&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;输入q回到主界面&quot;&lt;&lt;endl;      char *studentnum=(char*)malloc(NUMSIZE);      gets(studentnum);      if (strcmp(studentnum, &quot;q&quot;)==0) {          system(&quot;clear&quot;);          menu();          exit(1);      }      linklist check=searchnumchange(studentnum);      if(check){          while (check)          {          system(&quot;clear&quot;);          printsingle(check);              cout&lt;&lt;&quot;[1]修改姓名&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[2]修改学号&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[3]修改性别(男生为1，女生为2）&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[4]修改学院&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[5]修改专业&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[6]修改地址&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[7]修改电话&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[8]修改QQ&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[9]修改电子邮箱&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;[其他任意]返回主页面&quot;&lt;&lt;endl;              cout&lt;&lt;&quot;请输入你的选项:&quot;&lt;&lt;endl;          int n=-1;          scanf(&quot;%d&quot;,&amp;n);          if (!(n&lt;=9&amp;&amp;n&gt;=1)) {              changedata();          }          fflush(stdin);          cout&lt;&lt;&quot;修改为：&quot;&lt;&lt;endl;          char *change=(char*)malloc(sizeof(CHANGESIZE));          gets(change);          switch (n) {              case 1:                  strcpy(check-&gt;studentdata.name,change);                  break;              case 2:                  strcpy(check-&gt;studentdata.num, change);                  break;              case 3:                  if(strcmp(change,&quot;1&quot;)==0)                      check-&gt;studentdata.sex=1;                  else if(strcmp(change,&quot;2&quot;)==0)                      check-&gt;studentdata.sex=0;                  break;              case 4:                  strcpy(check-&gt;studentdata.college, change);                  break;              case 5:                  strcpy(check-&gt;studentdata.major, change);                  break;              case 6:                  strcpy(check-&gt;studentdata.add, change);                  break;              case 7:                  strcpy(check-&gt;studentdata.tel, change);                  break;              case 8:                  strcpy(check-&gt;studentdata.QQ, change);                  break;              case 9:                  strcpy(check-&gt;studentdata.email, change);                  break;              default:                  break;          }          fflush(stdin);          cout&lt;&lt;&quot;修改成功!!!!&quot;&lt;&lt;endl;          cout&lt;&lt;&quot;需要继续修改吗（y/n）?&quot;&lt;&lt;endl;          char *goon=(char*)malloc(sizeof(4));              gets(goon);              if (strcmp(goon,&quot;y&quot;)==0||strcmp(goon, &quot;Y&quot;)==0) {                  free(goon);                  continue;              }              else{                  free(change);                  free(studentnum);                  free(goon);                  system(&quot;clear&quot;);                  menu();                  exit(1);              }      }      }      else{          free(studentnum);          system(&quot;clear&quot;);          printf(&quot;NOT FOUND&quot;);          changedata();          exit(1);      }  }  linklist searchnumchange(char *search){      Node *p=head-&gt;next;      while (p!=NULL) {          if (checksubstr(p-&gt;studentdata.num, search)==1) {              return p;          }          p=p-&gt;next;      }      return NULL;  }  //**************************************************************  //*************                                  ***************  //*************           查找数据模块             ***************  //*************                                  ***************  //**************************************************************  void Find(void){      cout&lt;&lt;&quot;|-------------------------------&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[1]-按【姓名】统计与查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[2]-按【学号】统计与查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[3]-按【电话】查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[4]-按【QQ】查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[5]-按【学院】统计与查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[6]-按【专业】统计与查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[7]-按【地址】统计与查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[8]-按【性别】统计与查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[9]-关键字查找&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;｜----[0]-返回主界面&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;****************************************************************************&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;*********                   caution!                  **********************&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;*********    按特征查找支持模糊查找，例如：姓名可输入姓氏查找   *************&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;*********           关键字查找会对所有特征进行查找           *******************&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;***************************************************************************&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;请输入选项:&quot;&lt;&lt;endl;      int n = 0;      scanf(&quot;%d&quot;,&amp;n);      fflush(stdin);      switch (n) {          case 1:              system(&quot;clear&quot;);              Findname();              break;          case 2:              system(&quot;clear&quot;);              Findnum();              break;          case 3:              system(&quot;clear&quot;);              Findtel();              break;          case 4:              system(&quot;clear&quot;);              FindQQ();              break;          case 5:              system(&quot;clear&quot;);              Findcollege();              break;          case 6:              system(&quot;clear&quot;);              Findmajor();              break;          case 7:              system(&quot;clear&quot;);              Findaddress();              break;          case 8:              system(&quot;clear&quot;);              Findsex();              break;          case 9:              system(&quot;clear&quot;);              Findall();              break;          default:              system(&quot;clear&quot;);              menu();              break;      }  }  linklist findthefront(char *search){      Node *p=head-&gt;next;      while (p!=NULL) {          if (checksubstr(p-&gt;next-&gt;studentdata.num, search)==1) {              return p;          }          p=p-&gt;next;      }      return NULL;  }  //**************************************************************  //*************                                  ***************  //*************           关键字查找模块             ***************  //*************                                  ***************  //**************************************************************  int Findall(){      cout&lt;&lt;&quot;请输入关键字：\n&quot;&lt;&lt;endl;      char *search=(char*)malloc(sizeof(char)*15);      gets(search);      searchall(search);      free(search);      printf(&quot;\n按两次任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchall(char *search){      Node *p=head-&gt;next;      int n=0;      while (p!=NULL) {          if (checksubstr(p-&gt;studentdata.num, search)||              checksubstr(p-&gt;studentdata.name, search)||              checksubstr(p-&gt;studentdata.tel, search)||              checksubstr(p-&gt;studentdata.QQ, search)||              checksubstr(p-&gt;studentdata.add, search)||              checksubstr(p-&gt;studentdata.college, search)||              checksubstr(p-&gt;studentdata.email, search)||              checksubstr(p-&gt;studentdata.major, search)) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************           查找学院模块             ***************  //*************                                  ***************  //**************************************************************  int Findcollege(){      cout&lt;&lt;&quot;请输入学院或学院名称关键字：\n&quot;&lt;&lt;endl;      char *search=(char*)malloc(sizeof(char)*15);      gets(search);      searchcollege(search);      free(search);      printf(&quot;\n按两次任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchcollege(char *search){      Node *p=head-&gt;next;      int n=0;      while (p!=NULL) {          if (checksubstr(p-&gt;studentdata.college, search)==1) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************           查找专业模块             ***************  //*************                                  ***************  //**************************************************************  int Findmajor(){      cout&lt;&lt;&quot;请输入学院或学院名称关键字：\n&quot;&lt;&lt;endl;      char *search=(char*)malloc(sizeof(char)*15);      gets(search);      searchmajor(search);      free(search);      printf(&quot;\n按两次任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchmajor(char *search){      Node *p=head-&gt;next;      int n=0;      while (p!=NULL) {          if (checksubstr(p-&gt;studentdata.major, search)==1) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************           查找地址模块             ***************  //*************                                  ***************  //**************************************************************  int Findaddress(){      cout&lt;&lt;&quot;请输入专业或专业名称关键字：\n&quot;&lt;&lt;endl;      char *search=(char*)malloc(sizeof(char)*15);      gets(search);      searchcollege(search);      free(search);      printf(&quot;\n按任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchaddress(char *search){      Node *p=head-&gt;next;      int n=0;      while (p!=NULL) {          if (checksubstr(p-&gt;studentdata.add, search)==1) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************           查找性别模块             ***************  //*************                                  ***************  //**************************************************************  int Findsex(){      cout&lt;&lt;&quot;请输入性别（男生键入数字1，女生键入数字0）：\n&quot;&lt;&lt;endl;      int search = -1;      scanf(&quot;%d&quot;,&amp;search);      searchsex(search);      printf(&quot;\n按两次任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchsex(int search){      int n = 0;      Node *p=head-&gt;next;      while (p!=NULL) {          if (p-&gt;studentdata.sex==search) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************           查找学号模块             ***************  //*************                                  ***************  //**************************************************************  int Findnum(){      cout&lt;&lt;&quot;请输入学号或部分学号：\n&quot;&lt;&lt;endl;      char *search=(char*)malloc(sizeof(char)*15);      gets(search);      searchnum(search);      free(search);      printf(&quot;\n按两次任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchnum(char *search){      Node *p=head-&gt;next;      int n=0;      while (p!=NULL) {          if (checksubstr(p-&gt;studentdata.num, search)==1) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************           查找姓名模块             ***************  //*************                                  ***************  //**************************************************************  int Findname(){      cout&lt;&lt;&quot;请输入姓名或关键字：\n&quot;&lt;&lt;endl;      char *search=(char*)malloc(sizeof(char)*15);      gets(search);      searchname(search);      free(search);      printf(&quot;\n按两次任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchname(char *search){      Node *p=head-&gt;next;      int n = 0;      while (p) {          if (checksubstr(p-&gt;studentdata.name, search)==1) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************           查找电话模块             ***************  //*************                                  ***************  //**************************************************************  int Findtel(){      cout&lt;&lt;&quot;请输入电话或部分电话号码：\n&quot;&lt;&lt;endl;      char *search=(char*)malloc(sizeof(char)*15);      gets(search);      searchtel(search);      free(search);      printf(&quot;\n按两次任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchtel(char *search){      Node *p=head-&gt;next;      int n = 0;      while (p!=NULL) {          if (checksubstr(p-&gt;studentdata.tel, search)==1) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************           查找QQ模块             ***************  //*************                                  ***************  //**************************************************************  int FindQQ(){      cout&lt;&lt;&quot;请输入QQ号或部分QQ号：\n&quot;&lt;&lt;endl;      char *search=(char*)malloc(sizeof(char)*15);      gets(search);      searchQQ(search);      free(search);      printf(&quot;\n按两次任意键返回查找界面&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      Find();      return 0;  }  void searchQQ(char *search){      Node *p=head-&gt;next;      int n = 0;      while (p!=NULL) {          if (checksubstr(p-&gt;studentdata.QQ, search)==1) {              n++;              printsingle(p);          }          p=p-&gt;next;      }      printf(&quot;\n查找完毕,共%d条结果&quot;,n);  }  //**************************************************************  //*************                                  ***************  //*************      打印单个节点内的数据            ***************  //*************                                  ***************  //**************************************************************  void printsingle(Node *p){      int sex=p-&gt;studentdata.sex;      char sexchar[4];      if (sex==0) {          strcpy(sexchar, &quot;女&quot;);      }      else{          strcpy(sexchar, &quot;男&quot;);      }      printf(&quot;%-15s&quot;,p-&gt;studentdata.name);//名字位数      printf(&quot;%-10s\t&quot;,p-&gt;studentdata.num);//学号位数      printf(&quot;%-7s&quot;,sexchar);      printf(&quot;%-10s&quot;,p-&gt;studentdata.college);//学院      printf(&quot;%-32s&quot;,p-&gt;studentdata.major);//专业      printf(&quot;%-24s&quot;,p-&gt;studentdata.add);//address      printf(&quot;%-16s&quot;,p-&gt;studentdata.tel);      printf(&quot;%-12s&quot;,p-&gt;studentdata.QQ);      printf(&quot;%s&quot;,p-&gt;studentdata.email);  }  //**************************************************************  //*************                                  ***************  //*************      检查字符串中是否包含某段字符串    ***************  //*************                                  ***************  //**************************************************************  int checksubstr(char *str,char *sub_str)  {      int count = 0;      for(int i=0;i&lt;strlen(str);i++)      {          int j = 0;          for(;j&lt;strlen(sub_str);j++)          {              if(*(sub_str+j)!=*(str+i+j))                  break;          }          if(j==strlen(sub_str))count++;      }      if (count&gt;0) {          return 1;      }      else{          return 0 ;      }  }  //**************************************************************  //*************                                  ***************  //*************           输出数据模块             ***************  //*************                                  ***************  //**************************************************************  void output(){      system(&quot;clear&quot;);      cout&lt;&lt;&quot;键入\t1\t以确定输出所有的数据&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;键入\t2\t以回到主界面&quot;&lt;&lt;endl;      int n;      scanf(&quot;%d&quot;,&amp;n);      switch (n) {          case 1:              system(&quot;clear&quot;);              printlink();              break;          case 2:              system(&quot;clear&quot;);              menu();          default:              system(&quot;clear&quot;);              output();              break;      }  }  //**************************************************************  //*************                                  ***************  //*************           打印全部数据            ***************  //*************                                  ***************  //**************************************************************  void printlink(){      Node *p=head-&gt;next;      cout&lt;&lt;&quot;name       \t&quot;      &lt;&lt;&quot;number      \t&quot;      &lt;&lt;&quot;sex   &quot;      &lt;&lt;&quot;college   &quot;      &lt;&lt;&quot;major   \t\t\t&quot;      &lt;&lt;&quot;address     \t\t&quot;      &lt;&lt;&quot;tel             &quot;      &lt;&lt;&quot;QQ          &quot;      &lt;&lt;&quot;Email       &quot;      &lt;&lt;endl;      while (p) {          int sex=p-&gt;studentdata.sex;          char sexchar[4];          if (sex==0) {              strcpy(sexchar, &quot;女&quot;);          }          else{              strcpy(sexchar, &quot;男&quot;);          }          printf(&quot;%-15s&quot;,p-&gt;studentdata.name);//名字位数          printf(&quot;%-10s\t&quot;,p-&gt;studentdata.num);//学号位数          printf(&quot;%-7s&quot;,sexchar);          printf(&quot;%-10s&quot;,p-&gt;studentdata.college);//学院          printf(&quot;%-32s&quot;,p-&gt;studentdata.major);//专业          printf(&quot;%-24s&quot;,p-&gt;studentdata.add);//address          printf(&quot;%-16s&quot;,p-&gt;studentdata.tel);          printf(&quot;%-12s&quot;,p-&gt;studentdata.QQ);          printf(&quot;%s&quot;,p-&gt;studentdata.email);          p=p-&gt;next;      }      printf(&quot;\n输出完毕\n键入回车以回到主菜单&quot;);      getchar();      getchar();      system(&quot;clear&quot;);      menu();  }  //**************************************************************  //*************                                  ***************  //*************           从文件导入模块             ***************  //*************                                  ***************  //**************************************************************  void input(){      fflush(stdin);      if ((head-&gt;next-&gt;studentdata.name)!=NULL) {          printf(&quot;已导入，若要加入数据，请在主菜单选择添加\n&quot;);          printf(&quot;键入yes覆盖以前的数据\n&quot;);          printf(&quot;键入其他键返回主菜单\n&quot;);          char check[3]={0};          gets(check);          if (strcmp(check, &quot;yes&quot;)==0) {          }          else{              system(&quot;clear&quot;);              menu();              exit(1);          }      }      cout&lt;&lt;&quot;|-------------------------------&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;返回上一级则按回车键&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;请输入导入文件路径：&quot;&lt;&lt;endl;      char filepath[FILEPATHSIZE];      gets(filepath);      if (filepath[0]==&#39;\0&#39;) {          system(&quot;clear&quot;);          menu();      }      FILE *fp;      while ((fp=fopen(filepath, &quot;r&quot;))==NULL) {          printf(&quot;NOT FOUND！！请再次输入:\n&quot;);          gets(filepath);          if (filepath[0]==&#39;\0&#39;)          {              system(&quot;clear&quot;);              menu();              break;          }      }              create(filepath);              system(&quot;clear&quot;);      cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      导入成功！       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl;              menu();  }  //**************************************************************  //*************                                  ***************  //*************           导入文件并创建链表             ***************  //*************                                  ***************  //**************************************************************  void create(char filepath[FILEPATHSIZE]){      FILE *fp;      fp=fopen(filepath, &quot;r&quot;);      linknode *p,*q;      p=q=::head;      char buffer[1024];      char *line,*record;//c保存行数据,单个列元素      line=fgets(buffer, sizeof(buffer), fp);//丢掉第一行      while ((line=fgets(buffer, sizeof(buffer), fp))!=NULL) {          q=(Node*)malloc(sizeof(Node));          record = strtok(line, &quot;,&quot;);          strcpy(q-&gt;studentdata.name,record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.num,record);          record = strtok(NULL, &quot;,&quot;);          q-&gt;studentdata.sex=atoi(record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.college,record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.major, record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.add, record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.tel,record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.QQ,record);          record = strtok(NULL, &quot;,&quot;);          strcpy(q-&gt;studentdata.email, record);          p-&gt;next=q;          p=q;      }      p-&gt;studentdata.email[strlen(q-&gt;studentdata.email)+1]=&#39;\0&#39;;      p-&gt;studentdata.email[strlen(q-&gt;studentdata.email)]=&#39;\n&#39;;      p-&gt;next=NULL;      fclose(fp);  }  //**************************************************************  //*************                                  ***************  //*************           发送邮件             ***************  //*************                                  ***************  //**************************************************************  void send(){      fflush(stdin);      cout&lt;&lt;&quot;请输入同学姓名&quot;&lt;&lt;endl;      cout&lt;&lt;&quot;输入【1】返回主菜单&quot;&lt;&lt;endl;      char *name=(char*)malloc(NAMESIZE);      gets(name);      Node *p=head;      if (strcmp(name,&quot;1&quot;)==0) {          system(&quot;clear&quot;);          menu();          exit(1);      }      while (p) {          if (strcmp(p-&gt;studentdata.name,name)==0) {              break;          }          else{              p=p-&gt;next;          }      }      printsingle(p);      free(name);      sendto(p-&gt;studentdata.email);      system(&quot;clear&quot;);      cout&lt;&lt;&quot;成功&quot;&lt;&lt;endl;      menu();      exit(1);  }</code></pre><p>​<br>​      void sendto(char *email)<br>​      {<br>​          printf(“1”);<br>​          char body[] = “From: \”lucy\”<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#49;&#x31;&#x39;&#52;&#55;&#x39;&#56;&#49;&#54;&#48;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;">&#49;&#x31;&#x39;&#52;&#55;&#x39;&#56;&#49;&#54;&#48;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;</a>\r\n”//这是我自己的邮箱<br>​          “To: \”dasiy\”<a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x31;&#x31;&#57;&#x34;&#55;&#x39;&#x38;&#x31;&#x36;&#48;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#x31;&#57;&#x34;&#55;&#x39;&#x38;&#x31;&#x36;&#48;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;</a>\r\n”//也是我自己的<br>​          “Subject: caution\r\n\r\n”//主题<br>​          “Fail the test”;//内容<br>​          sendemail(email, body);<br>​      }<br>​<br>      char con628(char c6)<br>      {<br>          printf(“1”);<br>          char rtn = ‘\0’;<br>          if (c6 &lt; 26) rtn = c6 + 65;<br>          else if (c6 &lt; 52) rtn = c6 + 71;<br>          else if (c6 &lt; 62) rtn = c6 - 4;<br>          else if (c6 == 62) rtn = 43;<br>          else rtn = 47;<br>          return rtn;<br>      }</p><pre><code>  // base64的实现  void base64(char *dbuf, char *buf128, int len)  {      printf(&quot;1&quot;);      struct data6 *ddd = NULL;      int i = 0;      char buf[256] = {0};      char *tmp = NULL;      char cc = &#39;\0&#39;;      memset(buf, 0, 256);      strcpy(buf, buf128);      for(i = 1; i &lt;= len/3; i++)      {      tmp = buf+(i-1)*3;      cc = tmp[2];      tmp[2] = tmp[0];      tmp[0] = cc;      ddd = (struct data6 *)tmp;      dbuf[(i-1)*4+0] = con628((unsigned int)ddd-&gt;d1);      dbuf[(i-1)*4+1] = con628((unsigned int)ddd-&gt;d2);      dbuf[(i-1)*4+2] = con628((unsigned int)ddd-&gt;d3);      dbuf[(i-1)*4+3] = con628((unsigned int)ddd-&gt;d4);      }      if(len%3 == 1)      {      tmp = buf+(i-1)*3;      cc = tmp[2];      tmp[2] = tmp[0];      tmp[0] = cc;      ddd = (struct data6 *)tmp;      dbuf[(i-1)*4+0] = con628((unsigned int)ddd-&gt;d1);      dbuf[(i-1)*4+1] = con628((unsigned int)ddd-&gt;d2);      dbuf[(i-1)*4+2] = &#39;=&#39;;      dbuf[(i-1)*4+3] = &#39;=&#39;;      }      if(len%3 == 2)      {      tmp = buf+(i-1)*3;      cc = tmp[2];      tmp[2] = tmp[0];      tmp[0] = cc;      ddd = (struct data6 *)tmp;      dbuf[(i-1)*4+0] = con628((unsigned int)ddd-&gt;d1);      dbuf[(i-1)*4+1] = con628((unsigned int)ddd-&gt;d2);      dbuf[(i-1)*4+2] = con628((unsigned int)ddd-&gt;d3);      dbuf[(i-1)*4+3] = &#39;=&#39;;      }      return;  }  void sendemail(char *email, char *body)  {      printf(&quot;1&quot;);      int sockfd = 0;      struct sockaddr_in their_addr = {0};      char buf[1500] = {0};      char rbuf[1500] = {0};      char login[128] = {0};      char pass[128] = {0};      memset(&amp;their_addr, 0, sizeof(their_addr));      their_addr.sin_family = AF_INET;      their_addr.sin_port = htons(25);      their_addr.sin_addr.s_addr = inet_addr(&quot;112.90.141.71&quot;);//qq smtp 服务器      // 连接邮件服务器，如果连接后没有响应，则2 秒后重新连接      sockfd = open_socket((struct sockaddr *)&amp;their_addr);      memset(rbuf,0,1500);      while(recv(sockfd, rbuf, 1500, 0) == 0)      {          printf(&quot;reconnect...\n&quot;);          sleep(2);          //close(sockfd);          sockfd = open_socket((struct sockaddr *)&amp;their_addr);          memset(rbuf,0,1500);      }      printf(&quot;%s\n&quot;, rbuf);      // EHLO      memset(buf, 0, 1500);      sprintf(buf, &quot;EHLO abcdefg-PC\r\n&quot;);      send(sockfd, buf, strlen(buf), 0);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      // AUTH LOGIN      memset(buf, 0, 1500);      sprintf(buf, &quot;AUTH LOGIN\r\n&quot;);      send(sockfd, buf, strlen(buf), 0);      printf(&quot;%s\n&quot;, buf);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      // USER      memset(buf, 0, 1500);      sprintf(buf,&quot;qq！！！！！！&quot;);//你的qq号      memset(login, 0, 128);      base64(login, buf, (int)strlen(buf));      sprintf(buf, &quot;%s\r\n&quot;, login);      send(sockfd, buf, strlen(buf), 0);      printf(&quot;%s\n&quot;, buf);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      // PASSWORD      sprintf(buf, &quot;密码！！！！&quot;);      memset(pass, 0, 128);      base64(pass, buf, (int)strlen(buf));      sprintf(buf, &quot;%s\r\n&quot;, pass);      send(sockfd, buf, strlen(buf), 0);      printf(&quot;%s\n&quot;, buf);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      // MAIL FROM      memset(buf, 0, 1500);      sprintf(buf, &quot;MAIL FROM: &lt;1194798160@qq.com&gt;\r\n&quot;);      send(sockfd, buf, strlen(buf), 0);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      // RCPT TO 第一个收件人      sprintf(buf, &quot;RCPT TO:&lt;%s&gt;\r\n&quot;, email);      send(sockfd, buf, strlen(buf), 0);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      // DATA 准备开始发送邮件内容      sprintf(buf, &quot;DATA\r\n&quot;);      send(sockfd, buf, strlen(buf), 0);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      // 发送邮件内容，\r\n.\r\n内容结束标记      sprintf(buf, &quot;%s\r\n.\r\n&quot;, body);      send(sockfd, buf, strlen(buf), 0);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      // QUIT      sprintf(buf, &quot;QUIT\r\n&quot;);      send(sockfd, buf, strlen(buf), 0);      memset(rbuf, 0, 1500);      recv(sockfd, rbuf, 1500, 0);      printf(&quot;%s\n&quot;, rbuf);      close(sockfd);      return;  }      // 打开TCP Socket连接  int open_socket(struct sockaddr *addr)  {      printf(&quot;1&quot;);          int sockfd = 0;          sockfd=socket(PF_INET, SOCK_STREAM, 0);          if(sockfd &lt; 0)          {              fprintf(stderr, &quot;Open sockfd(TCP) error!\n&quot;);              _exit(-1);          }          if(connect(sockfd, addr, sizeof(struct sockaddr)) &lt; 0)          {              fprintf(stderr, &quot;Connect sockfd(TCP) error!\n&quot;);              _exit(-1);          }          return sockfd;  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指针</tag>
      
      <tag>c语言</tag>
      
      <tag>c++</tag>
      
      <tag>算法</tag>
      
      <tag>课程设计</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言指针的应用</title>
    <link href="/2019/12/17/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2019/12/17/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>[行指针和列指针详解]<a href="https://blog.csdn.net/u013431550/article/details/43057537" target="_blank" rel="noopener">https://blog.csdn.net/u013431550/article/details/43057537</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>资源分享</tag>
      
      <tag>指针</tag>
      
      <tag>c语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(4)</title>
    <link href="/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-4/"/>
    <url>/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-4/</url>
    
    <content type="html"><![CDATA[<ul><li>验证 (Validation)</li><li>表示 (Representation)<a id="more"></a><h1 id="验证-Validation"><a href="#验证-Validation" class="headerlink" title="验证 (Validation)"></a>验证 (Validation)</h1><h2 id="更好的工作流程"><a href="#更好的工作流程" class="headerlink" title="更好的工作流程"></a>更好的工作流程</h2></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/WorkflowWithValidationSet.svg" srcset="/img/loading.gif" alt></li><li>在这一经过改进的工作流程中：<ul><li>选择在验证集上获得最佳效果的模型。</li><li>使用测试集再次检查该模型。</li><li>该工作流程之所以更好，原因在于它暴露给测试集的信息更少。<h1 id="表示-Representation"><a href="#表示-Representation" class="headerlink" title="表示 (Representation)"></a>表示 (Representation)</h1><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2></li></ul></li><li>机器学习模型不能直接看到、听到或感知输入样本。您必须创建数据表示，为模型提供有用的信号来了解数据的关键特性。也就是说，为了训练模型，您必须选择最能代表数据的特征集。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>machine learning</tag>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(3)</title>
    <link href="/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-3/"/>
    <url>/2019/12/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-3/</url>
    
    <content type="html"><![CDATA[<ul><li>使用 TensorFlow 的起始步骤 (First Steps with TensorFlow)</li><li>泛化 (Generalization)</li><li>练集和测试集 (Training and Test Sets)<a id="more"></a><h1 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h1><h2 id="TensorFlow-工具包"><a href="#TensorFlow-工具包" class="headerlink" title="TensorFlow 工具包"></a>TensorFlow 工具包</h2></li><li><p><img src="https://developers.google.cn/machine-learning/crash-course/images/TFHierarchy.svg" srcset="/img/loading.gif" alt></p><h2 id="tf-estimator-API"><a href="#tf-estimator-API" class="headerlink" title="tf.estimator API"></a>tf.estimator API</h2><p>以下是在 tf.estimator 中实现的线性回归程序的格式：</p><p>  import tensorflow as tf</p><h1 id="Set-up-a-linear-classifier"><a href="#Set-up-a-linear-classifier" class="headerlink" title="Set up a linear classifier."></a>Set up a linear classifier.</h1><p>  classifier = tf.estimator.LinearClassifier()</p><h1 id="Train-the-model-on-some-example-data"><a href="#Train-the-model-on-some-example-data" class="headerlink" title="Train the model on some example data."></a>Train the model on some example data.</h1><p>  classifier.train(input_fn=train_input_fn, steps=2000)</p><h1 id="Use-it-to-predict"><a href="#Use-it-to-predict" class="headerlink" title="Use it to predict."></a>Use it to predict.</h1><p>  predictions = classifier.predict(input_fn=predict_input_fn)</p><h1 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化 (Generalization)"></a>泛化 (Generalization)</h1></li><li>泛化是指模型很好地拟合以前未见过的新数据（从用于创建该模型的同一分布中抽取）的能力。<h2 id="过拟合的风险"><a href="#过拟合的风险" class="headerlink" title="过拟合的风险"></a>过拟合的风险</h2></li><li><ul><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GeneralizationB.png" srcset="/img/loading.gif" alt></li><li>拟合</li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GeneralizationC.png" srcset="/img/loading.gif" alt></li><li>对比</li><li>损失很低，但仍然是糟糕的模型</li><li>过拟合是由于模型的复杂程度超出所需程度而造成的。机器学习的基本冲突是适当拟合我们的数据，但也要尽可能简单地拟合数据。<h2 id="奥卡姆剃刀定律"><a href="#奥卡姆剃刀定律" class="headerlink" title="奥卡姆剃刀定律"></a>奥卡姆剃刀定律</h2></li></ul></li><li><ul><li>奥卡姆的威廉是 14 世纪一位崇尚简单的修士和哲学家。他认为科学家应该优先采用更简单（而非更复杂）的公式或理论。</li><li>奥卡姆剃刀定律在机器学习方面的运用如下：<strong>机器学习模型越简单，良好的实证结果就越有可能不仅仅基于样本的特性。</strong></li><li><font color="red"> **如无必要，勿增实体** </font></li></ul></li><li>统计化描述模型根据以下因素泛化到新数据的能力：<ul><li>模型的复杂程度</li><li>模型在处理训练数据方面的表现</li></ul></li><li>据数据集构建模型，如何获得以前未见过的数据呢？一种方法是将您的数据集分成两个子集：<ul><li>训练集 - 用于训练模型的子集</li><li>测试集 - 用于测试模型的子集<h1 id="训练集和测试集-Training-and-Test-Sets"><a href="#训练集和测试集-Training-and-Test-Sets" class="headerlink" title="训练集和测试集 (Training and Test Sets)"></a>训练集和测试集 (Training and Test Sets)</h1><h2 id="拆分单个数据集"><a href="#拆分单个数据集" class="headerlink" title="拆分单个数据集"></a>拆分单个数据集</h2><img src="https://developers.google.cn/machine-learning/crash-course/images/PartitionTwoSets.svg" srcset="/img/loading.gif" alt><br><img src="https://developers.google.cn/machine-learning/crash-course/images/TrainingDataVsTestData.svg" srcset="/img/loading.gif" alt></li></ul></li><li>切勿训练测试数据</li><li>测试集应满足：<ul><li>能代表整个数据集。换言之，挑选的测试集的特征应该与训练集的特征相同。</li><li>规模足够大，可产生具有统计意义的结果</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>machine learning</tag>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
      <tag>TensorFlow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(2)</title>
    <link href="/2019/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-2/"/>
    <url>/2019/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-2/</url>
    
    <content type="html"><![CDATA[<p><strong>降低损失</strong></p><ul><li>迭代方法</li><li>梯度下降法</li><li>学习速率</li><li>优化学习速率</li><li>简单的练习<a id="more"></a><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2></li><li>hot and cold 游戏</li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GradientDescentDiagram.svg" srcset="/img/loading.gif" alt="迭代试错过程"></li><li><ul><li>初始值</li><li>计算损失</li><li>“计算参数更新”部分，机器学习系统就是在此部分检查损失函数的值，并为和生成新值。</li><li>学习过程会持续迭代，直到该算法发现损失可能最低的模型参数</li><li>不断迭代，直到总体损失不再变化或至少变化极其缓慢为止。这时候，我们可以说该模型已收敛。<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2></li></ul></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/GradientDescentGradientStep.svg" srcset="/img/loading.gif" alt="碗状图"><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3></li><li>函数的梯度是偏导数相对于所有自变量的矢量</li><li><ul><li>z = f(x,y) 就像一个山谷，最低点为 (2,0,4)：的梯度是一个二维矢量，可让您了   解向哪个 (x,y) 方向移动时高度下降得最快。也就是说，梯度矢量指向山谷。</li><li>梯度是矢量：具有大小和方向</li><li>在机器学习中，梯度用于梯度下降法。我们的损失函数通常具有很多变量，而我们尝试通过跟随函数梯度的负方向来尽量降低损失函数。<br><img src="https://developers.google.cn/machine-learning/crash-course/images/ThreeDimensionalPlot.svg" srcset="/img/loading.gif" alt><h2 id="学习速率"><a href="#学习速率" class="headerlink" title="学习速率"></a>学习速率</h2></li></ul></li><li>每个回归问题都存在一个金发姑娘学习速率。“金发姑娘”值与损失函数的平坦程度相关。</li><li>学习速率过大：如果您知道损失函数的梯度较小，则可以放心地试着采用更大的学习速率，以补偿较小的梯度并获得更大的步长。<br>  <img src="https://developers.google.cn/machine-learning/crash-course/images/LearningRateTooLarge.svg" srcset="/img/loading.gif" alt></li><li>学习速率过小花费更多时间<br>  <img src="https://developers.google.cn/machine-learning/crash-course/images/LearningRateTooSmall.svg" srcset="/img/loading.gif" alt><h4 id="待理解和解决的问题"><a href="#待理解和解决的问题" class="headerlink" title="待理解和解决的问题"></a>待理解和解决的问题</h4></li><li>一维空间中的理想学习速率是（f(x) 对 x 的二阶导数的倒数）。</li><li>二维或多维空间中的理想学习速率是海森矩阵（由二阶偏导数组成的矩阵）的倒数。</li><li>广义凸函数的情况则更为复杂。<h2 id="优化学习速率"><a href="#优化学习速率" class="headerlink" title="优化学习速率"></a>优化学习速率</h2><a href="https://developers.google.cn/machine-learning/crash-course/fitter/graph" target="_blank" rel="noopener">playground</a><h2 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h2></li><li>通过从我们的数据集中<strong>随机选择样本</strong>，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，<strong>它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱</strong>。</li><li>批量指的是用于在单次迭代中计算梯度的样本总数</li><li>批量大小越大，出现冗余的可能性就越高。一些冗余可能有助于消除杂乱的梯度，但超大批量所具备的预测价值<strong>往往并不比大型批量高</strong>。</li><li>“随机”这一术语表示<strong>构成各个批量的一个样本都是随机选择的</strong>。<h2 id="Playground"><a href="#Playground" class="headerlink" title="Playground"></a>Playground</h2></li><li><strong>playground</strong>&gt;&gt;&gt;<a href="http://playground.tensorflow.org/" target="_blank" rel="noopener">http://playground.tensorflow.org/</a></li><li><a href="https://developers.google.cn/machine-learning/crash-course/reducing-loss/playground-exercise" target="_blank" rel="noopener">playround简介</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>machine learning</tag>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：Machine Learning(1)</title>
    <link href="/2019/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-1/"/>
    <url>/2019/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AMachine-Learning-1/</url>
    
    <content type="html"><![CDATA[<ul><li>简介</li><li>框架处理</li><li>深入了解机器学习<a id="more"></a><h1 id="学习笔记：Machine-Learning-1"><a href="#学习笔记：Machine-Learning-1" class="headerlink" title="学习笔记：Machine Learning(1)"></a>学习笔记：Machine Learning(1)</h1></li><li>第一次接触machine learning</li><li>基于Google developer</li><li>参考<a href="https://developers.google.cn/machine-learning/crash-course" target="_blank" rel="noopener">https://developers.google.cn/machine-learning/crash-course</a><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2></li><li>由观察到统计而无需逻辑</li><li>最终延伸到自然科学</li><li>对大量样本<h2 id="问题构建"><a href="#问题构建" class="headerlink" title="问题构建"></a>问题构建</h2><h3 id="什么是（监督式）机器学习？"><a href="#什么是（监督式）机器学习？" class="headerlink" title="什么是（监督式）机器学习？"></a>什么是（监督式）机器学习？</h3></li><li>机器学习系统通过学习如何组合输入信息来对从未见过的数据做出有用的预测<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3></li><li>标签是我们要预测的事物，即简单线性回归中的 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3></li><li>特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征</li><li>在垃圾邮件检测器示例中，特征可能包括：<ul><li>电子邮件文本中的字词</li><li>发件人的地址</li><li>发送电子邮件的时段</li><li>电子邮件中包含“一种奇怪的把戏”这样的短语。<h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3></li></ul></li><li>样本是指数据的特定实例：<ul><li>有标签样本</li><li>无标签样本</li><li><ul><li><strong>我们使用有标签样本来训练模型。</strong>在垃圾邮件检测器中，有标签样本是用户明确标记为“垃圾邮件”或“非垃圾邮件”的各个电子邮件。</li><li><strong>在使用有标签样本训练模型之后，我们会使用该模型预测无标签样本的标签。</strong>在垃圾邮件检测器示例中，无标签样本是用户尚未添加标签的新电子邮件。</li></ul></li></ul></li><li><ul><li>labeled examples: {features, label}: (x, y) 有特征和标签<ul><li>例如房子的大小，房型，房间数；而房价则可称为标签；</li></ul></li><li>unlabeled examples: {features, ?}: (x, ?)  有特征而无标签<ul><li>房子大小房型知道，房价未知</li></ul></li></ul></li><li>个人理解：标签是更为主观的判断<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3></li><li>模型定义了特征与标签之间的关系。</li><li><strong>训练</strong>是指创建或学习模型。也就是说，向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。</li><li><strong>推断</strong>是指将训练后的模型应用于无标签样本。也就是说，使用经过训练的模型做出有用的预测 (y’)。例如，在推断期间，您可以针对新的无标签样本预测 medianHouseValue.<em>（即由房型，大小，房间数推断价格）</em><h3 id="回归与分类"><a href="#回归与分类" class="headerlink" title="回归与分类"></a>回归与分类</h3></li><li>回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题：<ul><li>加利福尼亚州一栋房产的价值是多少？</li><li>用户点击此广告的概率是多少？</li></ul></li><li>分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题：<ul><li>某个指定电子邮件是垃圾邮件还是非垃圾邮件？</li><li>这是一张狗、猫还是仓鼠图片？<h2 id="深入了解machin-learning"><a href="#深入了解machin-learning" class="headerlink" title="深入了解machin learning"></a>深入了解machin learning</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3></li></ul></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/CricketLine.svg" srcset="/img/loading.gif" alt="线性回归图"></li><li>即可简单的写出模型方程式<h3 id="训练与损失"><a href="#训练与损失" class="headerlink" title="训练与损失"></a>训练与损失</h3></li><li><img src="https://developers.google.cn/machine-learning/crash-course/images/LossSideBySide.png" srcset="/img/loading.gif" alt="1"></li><li>红色箭头表示损失,蓝线表示预测</li><li><strong>左侧模型的损失较大；右侧模型的损失较小</strong><h4 id="平方损失：一种常见的损失函数"><a href="#平方损失：一种常见的损失函数" class="headerlink" title="平方损失：一种常见的损失函数"></a>平方损失：一种常见的损失函数</h4>  = the square of the difference between the label and the prediction<br>  = (observation - prediction(x))2<br>  = (y - y’)2<h4 id="均方误差-MSE"><a href="#均方误差-MSE" class="headerlink" title="均方误差 (MSE)"></a>均方误差 (MSE)</h4></li><li>指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine learning</tag>
      
      <tag>机器学习</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于MATLAB的语音信号识别</title>
    <link href="/2019/12/02/%E5%9F%BA%E4%BA%8EMATLAB%E7%9A%84%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/"/>
    <url>/2019/12/02/%E5%9F%BA%E4%BA%8EMATLAB%E7%9A%84%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>在语音识别和话者识别方面，最常用到的语音特征就是梅尔倒谱系数（Mel-scaleFrequency Cepstral Coefficients，简称MFCC）。<br><a id="more"></a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><ul><li>本项目GitHub地址<a href="https://github.com/foresight100/matlab-.git" target="_blank" rel="noopener">https://github.com/foresight100/matlab-.git</a><h1 id="选择MFCC"><a href="#选择MFCC" class="headerlink" title="选择MFCC"></a>选择MFCC</h1></li><li>特征参数的好坏将直接影响系统的性能和效率，对特征参数的要求包括：</li><li><ul><li>(1)    提取的特征参数能有效地代表语音特征，具有很好的区分性；</li><li>(2)    各阶参数之间有良好的独立性；</li><li>(3)    特征参数要计算方便，最好有高效的计算方法，以保证语音识别的实时实现。</li></ul></li><li>LPCC的优点是计算量小，易于实现，对元音有较好的描述能力，<br>缺点是对辅音描述能力较差。</li><li><p>MFCC它响应不同频率信号的灵敏度是不同的，而Mel尺度倒谱系数能够比较充分利用人耳的这种特殊感知特性。</p></li><li><p>大量研究表明。MFCC系数能够比LPCC参数更好地提高系统的识别性能。</p></li></ul><h1 id="MAIN"><a href="#MAIN" class="headerlink" title="MAIN"></a>MAIN</h1><ul><li>语音特征MFCC提取过程<br><img src="http://static.oschina.net/uploads/space/2014/0115/164958_fSdw_852488.jpg" srcset="/img/loading.gif" alt="流程"></li><li>在语音识别和话者识别方面，最常用到的语音特征就是梅尔倒谱系数（Mel-scaleFrequency Cepstral Coefficients，简称MFCC）。</li><li>人耳对不同频率的声波有不同的听觉敏感度。从200Hz到5000Hz的语音信号对语音的清晰度影响对大。两个响度不等的声音作用于人耳时，则响度<strong>较高的频率成分的存在会影响到对响度较低</strong>的频率成分的感受，使其变得不易察觉，这种现象称为掩蔽效应。</li><li>由于频率较低的声音在内耳蜗基底膜上行波传递的距离大于频率较高的声音，故一般来说，低音容易掩蔽高音，而高音掩蔽低音较困难。在低频处的声音掩蔽的临界带宽较高频要小。</li><li>所以，<strong>人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征</strong>，对此特征经过进一步处理后就可以作为语音的输入特征。</li></ul><h2 id="语音信号预处理"><a href="#语音信号预处理" class="headerlink" title="语音信号预处理"></a>语音信号预处理</h2><h3 id="语音信号采集"><a href="#语音信号采集" class="headerlink" title="语音信号采集"></a>语音信号采集</h3><ul><li>可使用audiorecorder函数录制或由Windows的“录音机”程序录制成.wav文件然后使用audioread函数读入</li></ul><h3 id="分帧"><a href="#分帧" class="headerlink" title="分帧"></a>分帧</h3><ul><li>利用语音信号在短时间内频谱特性平稳的特点，将语音信号分为很小的时间段，即“帧”，来研究。我们的程序取帧长为256  ，帧移为80</li><li>简而言之，语音信号<font color="red"><strong>整体上不稳定，但局部上可以看作是稳定的</strong></font>,在以后的语音处理中，需要输入一个稳定的信号，所以需要对整个语音信号进行帧处理，即将其分割成多个片段。 </li><li>在10-30ms范围内，可以认为信号是稳定的。一般以不少于20毫秒为帧，约1/2的时间作为帧移位帧，帧移位是指相邻两帧之间的重叠区域，以避免相邻两帧的变化。</li></ul><h3 id="预加重"><a href="#预加重" class="headerlink" title="预加重"></a>预加重</h3><ul><li>将语音信号通过预加重滤波器来滤除低频干扰，而将对语音识别<font color="red"><strong>更为有用的高频部分</strong></font>进行频谱提升</li><li><strong>并不是在语音信号处理中任何时候都要进行预加重的</strong>，只有在需要提升高频分量时才进行预加重处理，例如共振峰提取时。</li><li><font color="red"> **往往高频信号含有更多的信息。**</font></li></ul><h3 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h3><ul><li><strong>加窗的目的就是让不太连续的地方（最后一个点和第一个的连接处）看上去平滑了，没有原来那么明显的突变了</strong></li><li>加窗有利于语音信号保持短时平稳性。在进行后续不同处理时选择窗口不同</li><li>函数窗的主要用于<font color="red"><strong>对截断处的不连续变化进行平滑，减少泄漏</strong>。</font>此外，加窗处理还有很多其它的原因，如减少噪声干扰、限定测试的持续时间、从频率接近的信号中分离出幅值不同的信号……</li><li><ul><li>在信号处理中，可以说加窗处理是一个必经的过程，因为我们的计算机只能处理有限长度的信号，因此原始信号X(t)要以T（采样时间）截断，即有限化，成为XT(t)后再进一步处理，这个过程序就是加窗处理，但什么时候用什么窗呢？</li><li>这时我们就要对所需用到的函数窗做一定的了解。在平时，我们用得最多的是矩形窗，这个也很容易理解，<font color="red"><strong>好像我们屋子里的窗口一样，透过窗口我们可以看到外面的世界，但在如果我们理窗口远一些的话，我们的看到的范围将减少，越远就越小</strong>。</font></li><li>实际的信号处理过程中，我们用的矩形窗，<strong>但矩形窗在边缘处将信号突然截断，窗外时域信息全部消失，导致在频域增加了频率分量的现象，即频谱泄漏</strong>。避免泄漏的最佳方法是满足整周期采样条件，但实际中是不可能做到的。</li><li>对于非整周期采样的情况，必须考虑如何减少加窗时造成的泄漏误差，主要的措施是使用合理的加窗函数，使信号截断的锐角钝化，从而使频谱的扩散减到最少。<h2 id="计算离散功率谱"><a href="#计算离散功率谱" class="headerlink" title="计算离散功率谱"></a>计算离散功率谱</h2></li></ul></li><li>信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察。对预处理的每帧进行离散傅立叶变换得到其频谱，再取模的平方作为离散功率<br>谱S(n)</li><li><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=c9f5c05add2a6059461de948495d5ffe/94cad1c8a786c917e7c47eaac33d70cf3ac75759.jpg" srcset="/img/loading.gif" alt="离散功率谱"></li><li><strong><font color="red">功率谱表示了信号功率随着频率的变化关系</font></strong><h2 id="将功率谱通过滤波器组"><a href="#将功率谱通过滤波器组" class="headerlink" title="将功率谱通过滤波器组"></a>将功率谱通过滤波器组</h2></li><li>MFCC考虑到了人类的听觉特征，先将线性频谱映射到基于听觉感知的Mel非线性频谱中，然后转换到倒谱上。<h2 id="取对数后做离散余弦变换"><a href="#取对数后做离散余弦变换" class="headerlink" title="取对数后做离散余弦变换"></a>取对数后做离散余弦变换</h2></li><li>在频谱图中，缓变信号和快变信号以乘积的方式耦合，所以取对数，使缓变信号和快变信号以相加的方式耦合。再取傅里叶逆变换，这样就能够将乘积变加法后的高频信号和低频信号的耦合分开来分析了<h2 id="动态差分系数的提取"><a href="#动态差分系数的提取" class="headerlink" title="动态差分系数的提取"></a>动态差分系数的提取</h2></li><li>标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分<br>谱来描述。通常会把动、静态特征结合起来以有效提高系统的识别性能。</li></ul><h2 id="加权与识别"><a href="#加权与识别" class="headerlink" title="加权与识别"></a>加权与识别</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><em><a href="https://www.ilovematlab.cn/thread-300509-1-1.html" target="_blank" rel="noopener">Matlab进行语音预加重处理</a></em></li><li><em><a href="https://blog.csdn.net/gxiaoyaya/article/details/73555195" target="_blank" rel="noopener">语音识别之——mfcc什么是汉明窗，为什么加汉明窗</a></em></li><li><em><a href="https://blog.csdn.net/liurong_cn/article/details/9812611" target="_blank" rel="noopener">基于DTW算法的语音识别原理与实现</a></em></li><li><em><a href="https://blog.csdn.net/jojozhangju/article/details/18678861" target="_blank" rel="noopener">语音特征MFCC提取过程详解</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>语音识别</tag>
      
      <tag>信息导论</tag>
      
      <tag>MFCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言中的排序方法</title>
    <link href="/2019/11/30/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <url>/2019/11/30/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><h3 id="算法描述："><a href="#算法描述：" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li><p>重复步骤1~3，直到排序完成。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void BubbleSort(int *arr, int size)    {        int i, j, tmp;        for (i = 0; i &lt; size - 1; i++) {            for (j = 0; j &lt; size - i - 1; j++) {                if (arr[j] &gt; arr[j+1]) {                    tmp = arr[j];                    arr[j] = arr[j+1];                    arr[j+1] = tmp;                }            }        }    }</code></pre></li></ul><h2 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h2><h3 id="算法描述：-1"><a href="#算法描述：-1" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li><p>n-1趟结束，数组有序化了。</p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void SelectionSort(int *arr, int size)  {      int i, j, k, tmp;      for (i = 0; i &lt; size - 1; i++) {          k = i;          for (j = i + 1; j &lt; size; j++) {              if (arr[j] &lt; arr[k]) {                  k = j;              }          }          tmp = arr[k];          arr[k] = arr[i];          arr[i] = tmp;      }  }</code></pre></li></ul><h2 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h2><h3 id="算法描述：-2"><a href="#算法描述：-2" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li><p>重复步骤2~5。</p><h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void InsertionSort(int *arr, int size)      {          int i, j, tmp;          for (i = 1; i &lt; size; i++) {              if (arr[i] &lt; arr[i-1]) {                  tmp = arr[i];                  for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j--) {                    arr[j+1] = arr[j];                  }                arr[j+1] = tmp;              }                }      }</code></pre></li></ul><h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><h3 id="算法描述：-3"><a href="#算法描述：-3" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li><p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h3 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void ShellSort(int *arr, int size)    {        int i, j, tmp, increment;        for (increment = size/ 2; increment &gt; 0; increment /= 2) {              for (i = increment; i &lt; size; i++) {                tmp = arr[i];                for (j = i - increment; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j -= increment) {                    arr[j + increment] = arr[j];                }                arr[j + increment] = tmp;          }        }    }</code></pre></li></ul><h2 id="5-归并排序（Merge-Sort）"><a href="#5-归并排序（Merge-Sort）" class="headerlink" title="5.归并排序（Merge Sort）"></a>5.归并排序（Merge Sort）</h2><h3 id="算法描述：-4"><a href="#算法描述：-4" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li><p>将两个排序好的子序列合并成一个最终的排序序列。</p><h3 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  #define MAXSIZE 100    void Merge(int *SR, int *TR, int i, int middle, int rightend)   {      int j, k, l;        for (k = i, j = middle + 1; i &lt;= middle &amp;&amp; j &lt;= rightend; k++) {            if (SR[i] &lt; SR[j]) {              TR[k] = SR[i++];          } else {               TR[k] = SR[j++];          }        }        if (i &lt;= middle) {          for (l = 0; l &lt;= middle - i; l++) {              TR[k + l] = SR[i + l];          }        }        if (j &lt;= rightend) {          for (l = 0; l &lt;= rightend - j; l++) {              TR[k + l] = SR[j + l];            }      }    }    void MergeSort(int *SR, int *TR1, int s, int t)   {        int middle;        int TR2[MAXSIZE + 1];        if (s == t) {          TR1[s] = SR[s];       } else {            middle = (s + t) / 2;          MergeSort(SR, TR2, s, middle);          MergeSort(SR, TR2, middle + 1, t);          Merge(TR2, TR1, s, middle, t);      }    }</code></pre></li></ul><h2 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6.快速排序（Quick Sort）"></a>6.快速排序（Quick Sort）</h2><h3 id="算法描述：-5"><a href="#算法描述：-5" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><h3 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void QuickSort(int *arr, int maxlen, int begin, int end)    {        int i, j;        if (begin &lt; end) {            i = begin + 1;            j = end;                  while (i &lt; j) {                if(arr[i] &gt; arr[begin]) {                    swap(&amp;arr[i], &amp;arr[j]);                   j--;                } else {                    i++;               }            }            if (arr[i] &gt;= arr[begin]) {                i--;            }            swap(&amp;arr[begin], &amp;arr[i]);                QuickSort(arr, maxlen, begin, i);            QuickSort(arr, maxlen, j, end);        }    }    void swap(int *a, int *b)      {        int temp;        temp = *a;        *a = *b;        *b = temp;    }</code></pre></li></ul><h2 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7.堆排序（Heap Sort）"></a>7.堆排序（Heap Sort）</h2><h3 id="算法描述：-6"><a href="#算法描述：-6" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li><p>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><h3 id="代码实现：-6"><a href="#代码实现：-6" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void Heapify(int *arr, int m, int size)    {        int i, tmp;        tmp = arr[m];        for (i = 2 * m; i &lt;= size; i *= 2) {            if (i + 1 &lt;= size &amp;&amp; arr[i] &lt; arr[i+1]) {                i++;            }            if (arr[i] &lt; tmp) {                break;            }            arr[m] = arr[i];            m = i;        }        arr[m] = tmp;    }    void BulidHeap(int *arr, int size)  {        int i;        for (i = n / 2; i &gt; 0; i--) {            Heapify(arr, i, size);        }    }    void swap(int *arr, int i, int j)    {        int tmp;        tmp = arr[i];        arr[i] = arr[j];        arr[j] = tmp;    }    void HeapSort(int *arr, int size)    {        int i;        BulidHeap(arr, size);        for (i = size; i &gt; 1; i--) {            swap(arr, 1, i);          Heapify(arr, 1, i - 1);      }    }</code></pre></li></ul><h2 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8.计数排序（Counting Sort）"></a>8.计数排序（Counting Sort）</h2><h3 id="算法描述：-7"><a href="#算法描述：-7" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p><h3 id="代码实现：-7"><a href="#代码实现：-7" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void CountingSort(int *A, int *B, int n, int k)    {        int *C = (int *)malloc(sizeof(int) * (k + 1));        int i;        for (i = 0; i &lt;= k; i++) {            C[i] = 0;        }        for (i = 0; i &lt; n; i++) {            C[A[i]]++;        }        for (i = 1; i &lt;= k; i++) {            C[i] = C[i] + C[i - 1];        }        for (i = n - 1; i &gt;= 0; i--) {            B[C[A[i]] - 1] = A[i];            C[A[i]]--;        }    }  </code></pre></li></ul><h2 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9.桶排序（Bucket Sort）"></a>9.桶排序（Bucket Sort）</h2><h3 id="算法描述：-8"><a href="#算法描述：-8" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li><p>从不是空的桶里把排好序的数据拼接起来。</p><h3 id="代码实现：-8"><a href="#代码实现：-8" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  void bucketSort(int *arr, int size, int max)  {      int i,j;      int buckets[max];      memset(buckets, 0, max * sizeof(int));      for (i = 0; i &lt; size; i++) {          buckets[arr[i]]++;       }      for (i = 0, j = 0; i &lt; max; i++) {          while((buckets[i]--) &gt;0)              arr[j++] = i;      }  }</code></pre></li></ul><h2 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10.基数排序（Radix Sort）"></a>10.基数排序（Radix Sort）</h2><h3 id="算法描述：-9"><a href="#算法描述：-9" class="headerlink" title="算法描述："></a>算法描述：</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h3 id="代码实现：-9"><a href="#代码实现：-9" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code>  int get_index(int num, int dec, int order)  {      int i, j, n;      int index;      int div;      for (i = dec; i &gt; order; i--) {          n = 1;          for (j = 0; j &lt; dec - 1; j++)              n *= 10;          div = num / n;          num -= div * n;          dec--;      }      n = 1;      for (i = 0; i &lt; order - 1; i++)          n *= 10;      index = num / n;      return index;  }  void RadixSort(int *arr, int len, int dec, int order)  {      int i, j;      int index;       int tmp[len];       int num[10];      memset(num, 0, 10 * sizeof(int));       memset(tmp, 0, len * sizeof(int));      if (dec &lt; order) {          return;      }      for (i = 0; i &lt; len; i++) {          index = get_index(arr[i], dec, order);          num[index]++;       }      for (i = 1; i &lt; 10; i++) {          num[i] += num[i-1];      }      for (i = len - 1; i &gt;= 0; i--) {          index = get_index(arr[i], dec, order);           j = --num[index];           tmp[j] = arr[i];       }      for (i = 0; i &lt; len; i++) {          arr[i] = tmp[i];       }      RadixSort(arr, len, dec, order+1);  }</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>c语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/11/30/hello-world/"/>
    <url>/2019/11/30/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="Do-not-just-seek-happiness-for-yourself-Seek-happiness-for-all-Through-kindness-Through-mercy"><a href="#Do-not-just-seek-happiness-for-yourself-Seek-happiness-for-all-Through-kindness-Through-mercy" class="headerlink" title="Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy."></a>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</h3><h4 id="David-Levithan"><a href="#David-Levithan" class="headerlink" title="David Levithan"></a>David Levithan</h4><h6 id="—Wide-Awake"><a href="#—Wide-Awake" class="headerlink" title="—Wide Awake"></a>—Wide Awake</h6>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
